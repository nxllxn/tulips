<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>困难难度 on Tulips</title>
    <link>https://www.tlst.cc/tags/%E5%9B%B0%E9%9A%BE%E9%9A%BE%E5%BA%A6/</link>
    <description>Recent content in 困难难度 on Tulips</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Copyright @ 2022 郁金香啊</copyright>
    <lastBuildDate>Tue, 17 May 2022 19:15:33 +0800</lastBuildDate><atom:link href="https://www.tlst.cc/tags/%E5%9B%B0%E9%9A%BE%E9%9A%BE%E5%BA%A6/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Merge k Sorted Lists</title>
      <link>https://www.tlst.cc/post/leetcode-23-merge-k-sorted-lists/</link>
      <pubDate>Tue, 17 May 2022 19:15:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-23-merge-k-sorted-lists/</guid>
      <description>给定n个按照升序排序的链表，将这n个链表合并成一个升序排序的链表并返回。
示例 示例 1:
输入: lists = [[1,4,5],[1,3,4],[2,6]] 输出: [1,1,2,3,4,4,5,6] 解释: 给定的三个链表是[1-&amp;gt;4-&amp;gt;5, 1-&amp;gt;3-&amp;gt;4, 2-&amp;gt;6]合并之后的结果是1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6 示例 2:
输入: lists = [] 输出: [] 示例 3:
输入: lists = [[]] 输出: [] 限制条件:
 k == lists.length 0 &amp;lt;= k &amp;lt;= 104 0 &amp;lt;= lists[i].length &amp;lt;= 500 -104 &amp;lt;= lists[i][j] &amp;lt;= 104 lists[i] is sorted in ascending order.</description>
    </item>
    
    <item>
      <title>3Sum</title>
      <link>https://www.tlst.cc/post/leetcode-15-3-sum/</link>
      <pubDate>Sat, 07 May 2022 21:16:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-15-3-sum/</guid>
      <description>给定一组整数，返回所有可能的三元组[nums[i], nums[j], nums[k]]，其中i != j, i != k, j != k，使得三元组之和等于零。
此处要求返回的三元组不能包含重复的组合。
示例 示例 1:
输入: nums = [-1,0,1,2,-1,-4] 输出: [[-1,-1,2],[-1,0,1]] 示例 2:
输入: nums = [] 输出: [] 示例 3:
输入: nums = [0] 输出: [] 限制条件:
 0 &amp;lt;= nums.length &amp;lt;= 3000 -105 &amp;lt;= nums[i] &amp;lt;= 105  解决方案 解决方案 1 - 排序 + 二分查找 此处题目要求找到三个数字，其和为零，我们可以先找两个数字，比如m和n，然后再找到第三个数字其等于0 - m - n。</description>
    </item>
    
    <item>
      <title>Regular Expression Matching</title>
      <link>https://www.tlst.cc/post/leetcode-10-regular-expression-matching/</link>
      <pubDate>Sun, 24 Apr 2022 21:05:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-10-regular-expression-matching/</guid>
      <description>初次看到这个题目时，给定测试用例，脑子倒是能够很快计算出是否匹配，但是具体怎么通过代码来进行实现却是一时间没太想清楚。后面看了很多的解决方案，大多数解决方案思路的话基本都是动态规划，此外也了解到一个FAM，有限自动机的概念，这个概念在实现正则表达式时好像还蛮有用的。
给定一个字符串S和一个模式P，实现一个正则匹配，此处我们仅需要支持.和*。其中，.匹配任意字符，*匹配零次或者多次前面的元素。注意此处是匹配，不是查找，也就是我们的模式必须恰好匹配整个字符串。
Regular Expression Matching 示例 1:
输入: s = &amp;#34;aa&amp;#34;, p = &amp;#34;a&amp;#34; 输出: false 解释: 模式只能匹配字符串中的一个字符 示例 2:
输入: s = &amp;#34;aa&amp;#34;, p = &amp;#34;a*&amp;#34; 输出: true 解释: *表示匹配前面这个元素一次或者多次，所以我们可以匹配a两次 示例 3:
输入: s = &amp;#34;ab&amp;#34;, p = &amp;#34;.*&amp;#34; 输出: true 解释: &amp;#34;.*&amp;#34;意味着我们可以匹配任意字符多次 限制条件:
 1 &amp;lt;= s.length &amp;lt;= 20 1 &amp;lt;= p.</description>
    </item>
    
    <item>
      <title>Median of Two Sorted Arrays</title>
      <link>https://www.tlst.cc/post/leetcode-4-medianof-two-sorted-arrays/</link>
      <pubDate>Wed, 20 Apr 2022 13:10:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-4-medianof-two-sorted-arrays/</guid>
      <description>给定两个有序的数组nums1和nums2，其对应的元素个数分别为m和n，返回这两个数组的中值。
解决方案总体的时间复杂度不能超过O(log (m+n))。
Median of Two Sorted Arrays 示例 示例 1:
输入: nums1 = [1,3], nums2 = [2] 输出: 2.00000 解释: 合并后的数组是[1,2,3]，中值是2. 示例 2:
输入: nums1 = [1,2], nums2 = [3,4] 输出: 2.50000 解释: 合并后的数组是[1,2,3,4]，中值是(2 + 3) / 2 = 2.5. 限制条件:
 nums1.length == m nums2.length == n 0 &amp;lt;= m &amp;lt;= 1000 0 &amp;lt;= n &amp;lt;= 1000 1 &amp;lt;= m + n &amp;lt;= 2000 -106 &amp;lt;= nums1[i], nums2[i] &amp;lt;= 106  解决方案 解决方案 1 - 合并数组 如果我们抛开时间复杂度的限制，我们将两个数组进行合并，然后再计算中值就比较简单了。但是整体的空间复杂度是O(m + n)，时间复杂度是O(m + n)。</description>
    </item>
    
  </channel>
</rss>
