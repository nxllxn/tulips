<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>困难难度 on Tulips</title>
    <link>https://www.tlst.cc/tags/%E5%9B%B0%E9%9A%BE%E9%9A%BE%E5%BA%A6/</link>
    <description>Recent content in 困难难度 on Tulips</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Copyright @ 2022 郁金香啊</copyright>
    <lastBuildDate>Sun, 24 Apr 2022 21:05:33 +0800</lastBuildDate><atom:link href="https://www.tlst.cc/tags/%E5%9B%B0%E9%9A%BE%E9%9A%BE%E5%BA%A6/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Regular Expression Matching</title>
      <link>https://www.tlst.cc/post/leetcode-10-regular-expression-matching/</link>
      <pubDate>Sun, 24 Apr 2022 21:05:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-10-regular-expression-matching/</guid>
      <description>初次看到这个题目时，给定测试用例，脑子倒是能够很快计算出是否匹配，但是具体怎么通过代码来进行实现却是一时间没太想清楚。后面看了很多的解决方案，大多数解决方案思路的话基本都是动态规划，此外也了解到一个FAM，有限自动机的概念，这个概念在实现正则表达式时好像还蛮有用的。
给定一个字符串S和一个模式P，实现一个正则匹配，此处我们仅需要支持.和*。其中，.匹配任意字符，*匹配零次或者多次前面的元素。注意此处是匹配，不是查找，也就是我们的模式必须恰好匹配整个字符串。
Regular Expression Matching 示例 1:
输入: s = &amp;#34;aa&amp;#34;, p = &amp;#34;a&amp;#34; 输出: false 解释: 模式只能匹配字符串中的一个字符 示例 2:
输入: s = &amp;#34;aa&amp;#34;, p = &amp;#34;a*&amp;#34; 输出: true 解释: *表示匹配前面这个元素一次或者多次，所以我们可以匹配a两次 示例 3:
输入: s = &amp;#34;ab&amp;#34;, p = &amp;#34;.*&amp;#34; 输出: true 解释: &amp;#34;.*&amp;#34;意味着我们可以匹配任意字符多次 限制条件:
 1 &amp;lt;= s.length &amp;lt;= 20 1 &amp;lt;= p.</description>
    </item>
    
    <item>
      <title>Median of Two Sorted Arrays</title>
      <link>https://www.tlst.cc/post/leetcode-4-medianof-two-sorted-arrays/</link>
      <pubDate>Wed, 20 Apr 2022 13:10:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-4-medianof-two-sorted-arrays/</guid>
      <description>给定两个有序的数组nums1和nums2，其对应的元素个数分别为m和n，返回这两个数组的中值。
解决方案总体的时间复杂度不能超过O(log (m+n))。
Median of Two Sorted Arrays 示例 示例 1:
输入: nums1 = [1,3], nums2 = [2] 输出: 2.00000 解释: 合并后的数组是[1,2,3]，中值是2. 示例 2:
输入: nums1 = [1,2], nums2 = [3,4] 输出: 2.50000 解释: 合并后的数组是[1,2,3,4]，中值是(2 + 3) / 2 = 2.5. 限制条件:
 nums1.length == m nums2.length == n 0 &amp;lt;= m &amp;lt;= 1000 0 &amp;lt;= n &amp;lt;= 1000 1 &amp;lt;= m + n &amp;lt;= 2000 -106 &amp;lt;= nums1[i], nums2[i] &amp;lt;= 106  解决方案 解决方案 1 - 合并数组 如果我们抛开时间复杂度的限制，我们将两个数组进行合并，然后再计算中值就比较简单了。但是整体的空间复杂度是O(m + n)，时间复杂度是O(m + n)。</description>
    </item>
    
  </channel>
</rss>
