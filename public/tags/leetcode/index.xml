<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>LeetCode on Tulips</title>
    <link>https://www.tlst.cc/tags/leetcode/</link>
    <description>Recent content in LeetCode on Tulips</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Copyright @ 2022 郁金香啊</copyright>
    <lastBuildDate>Wed, 20 Apr 2022 13:10:33 +0800</lastBuildDate><atom:link href="https://www.tlst.cc/tags/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Median of Two Sorted Arrays</title>
      <link>https://www.tlst.cc/post/leetcode-4-medianof-two-sorted-arrays/</link>
      <pubDate>Wed, 20 Apr 2022 13:10:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-4-medianof-two-sorted-arrays/</guid>
      <description>给定两个有序的数组nums1和nums2，其对应的元素个数分别为m和n，返回这两个数组的中值。
解决方案总体的时间复杂度不能超过O(log (m+n))。
Median of Two Sorted Arrays 示例 示例 1:
输入: nums1 = [1,3], nums2 = [2] 输出: 2.00000 解释: 合并后的数组是[1,2,3]，中值是2. 示例 2:
输入: nums1 = [1,2], nums2 = [3,4] 输出: 2.50000 解释: 合并后的数组是[1,2,3,4]，中值是(2 + 3) / 2 = 2.5. 限制条件:
 nums1.length == m nums2.length == n 0 &amp;lt;= m &amp;lt;= 1000 0 &amp;lt;= n &amp;lt;= 1000 1 &amp;lt;= m + n &amp;lt;= 2000 -106 &amp;lt;= nums1[i], nums2[i] &amp;lt;= 106  解决方案 解决方案 1 - 合并数组 如果我们抛开时间复杂度的限制，我们将两个数组进行合并，然后再计算中值就比较简单了。但是整体的空间复杂度是O(m + n)，时间复杂度是O(m + n)。</description>
    </item>
    
    <item>
      <title>Longest Substring Without Repeating Characters</title>
      <link>https://www.tlst.cc/post/leetcode-3-longest-substring-without-repeating-characters/</link>
      <pubDate>Wed, 20 Apr 2022 09:13:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-3-longest-substring-without-repeating-characters/</guid>
      <description>给定一个字符串，找到它里面不包含重复字符的最长的字串。
Longest Substring Without Repeating Characters 示例 示例 1:
输入: s = &amp;#34;abcabcbb&amp;#34; 输出: 3 解释: 满足条件的最长字串是&amp;#34;abc&amp;#34;，字符串长度是3 示例 2:
输入: s = &amp;#34;bbbbb&amp;#34; 输出: 1 解释: 满足条件的最长字串是&amp;#34;b&amp;#34;，长度是1 示例 3:
输入: s = &amp;#34;pwwkew&amp;#34; 输出: 3 解释: 满足条件的最长字串是&amp;#34;wke&amp;#34;，长度是3 Constraints:
 0 &amp;lt;= s.length &amp;lt;= 5 * 10000 字符串可能包含英文字母，数字，特殊符号以及空格  解决方案 解决方案 1 - BitSet class Solution {  public int lengthOfLongestSubstring(String s) {  java.</description>
    </item>
    
    <item>
      <title>Add Two Number</title>
      <link>https://www.tlst.cc/post/leetcode-2-add-two-number/</link>
      <pubDate>Tue, 19 Apr 2022 17:44:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-2-add-two-number/</guid>
      <description>给定两个非空的链表，分别代表两个非负整数，链表的每一个节点代表整数的一位数字，数字是按照倒序存储的。请对这两个数字进行求和，并将结果按照同样的格式进行返回。
此处我们假定，这两个数字不包含任何前置0，当然了除了数字0本身。
Add Two Number 示例 示例 1:
输入: l1 = [2,4,3], l2 = [5,6,4] 输出: [7,0,8] 解释: 342 + 465 = 807. 示例 2:
输入: l1 = [0], l2 = [0] 输出: [0] 示例 3:
输入: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] 输出: [8,9,9,9,0,0,0,1] Constraints:
 每一个数字的位数也即每个链表的长度限制在范围[1, 100]. 0 &amp;lt;= Node.</description>
    </item>
    
    <item>
      <title>LeetCode</title>
      <link>https://www.tlst.cc/post/leetcode/</link>
      <pubDate>Tue, 19 Apr 2022 12:44:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode/</guid>
      <description>之前得空在leetcode上面刷了一段时间的题目，前前后后一共有三百多道题目吧。先是把简单难度的题目中大家评价还不错的题目都刷了一遍，然后是leetcode前100的题目有些之前没覆盖到的也捡起来刷了一下，这些题目甚至还试了一下多种可能的解决方案。
前期刷题的时候，其实只是自己实现了一下，整个的解决方案比较繁琐，没有花时间在评论区多看一看。
其实当我仔细看了有些大佬的解决方案之后，有时候甚至会产生一些羞愧感，明明相似的题目我之前做过，为什么现在又不会了等等。
在刷前一百的题目的时候，我有仔细对比自己的解决方案和其他人提供的解决方案有什么不同，事实证明，在评论区泡一泡还是有不少收获的。所以现在又回过头来看下之前刷的题目，然后慢慢整理一遍。
列表  1 - Two Sum 2 - Add Two Number 3 - Longest Substring Without Repeating Characters 4 - Median of Two Sorted Arrays  </description>
    </item>
    
    <item>
      <title>Two Sum</title>
      <link>https://www.tlst.cc/post/leetcode-1-two-sum/</link>
      <pubDate>Tue, 19 Apr 2022 12:44:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-1-two-sum/</guid>
      <description>Two Sum 概述 给定一个整数数组和一个目标值，在数组中找到两个数字，满足这两个数字之和等于目标值，返回这两个数字的索引。
此处我们假定这个数组中只有一个组合满足上述条件，此外，你不能使用同一个数字两次。
你可以以任意顺序返回组合的索引。
示例 1:
输入: nums = [2,7,11,15], target = 9 输出: [0,1] 解释: Because nums[0] + nums[1] == 9, we return [0, 1]. 示例 2:
输入: nums = [3,2,4], target = 6 输出: [1,2] 示例 3:
输入: nums = [3,3], target = 6 输出: [0,1] 限制条件:</description>
    </item>
    
  </channel>
</rss>
