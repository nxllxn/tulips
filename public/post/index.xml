<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Blogs on Tulips</title>
    <link>https://www.tlst.cc/post/</link>
    <description>Recent content in Blogs on Tulips</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Copyright @ 2022 郁金香啊</copyright>
    <lastBuildDate>Sat, 07 May 2022 21:16:33 +0800</lastBuildDate><atom:link href="https://www.tlst.cc/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>3Sum</title>
      <link>https://www.tlst.cc/post/leetcode-15-3-sum/</link>
      <pubDate>Sat, 07 May 2022 21:16:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-15-3-sum/</guid>
      <description>给定一组整数，返回所有可能的三元组[nums[i], nums[j], nums[k]]，其中i != j, i != k, j != k，使得三元组之和等于零。
此处要求返回的三元组不能包含重复的组合。
示例 示例 1:
输入: nums = [-1,0,1,2,-1,-4] 输出: [[-1,-1,2],[-1,0,1]] 示例 2:
输入: nums = [] 输出: [] 示例 3:
输入: nums = [0] 输出: [] 限制条件:
 0 &amp;lt;= nums.length &amp;lt;= 3000 -105 &amp;lt;= nums[i] &amp;lt;= 105  解决方案 解决方案 1 - 排序 + 二分查找 此处题目要求找到三个数字，其和为零，我们可以先找两个数字，比如m和n，然后再找到第三个数字其等于0 - m - n。</description>
    </item>
    
    <item>
      <title>1024 - Prime Number</title>
      <link>https://www.tlst.cc/post/1024-prime-numbers/</link>
      <pubDate>Fri, 06 May 2022 21:13:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/1024-prime-numbers/</guid>
      <description>import java.util.ArrayList; import java.util.BitSet;  public class Solution {  public List&amp;lt;Integer&amp;gt; primeNumbers(int range) {  BitSet bitSet = new BitSet(range + 1);   for (int num = 2; num &amp;lt;= range &amp;gt;&amp;gt; 1; num++) {  int times = 2;  while (num * times &amp;lt;= range) {  bitSet.</description>
    </item>
    
    <item>
      <title>Longest Common Prefix</title>
      <link>https://www.tlst.cc/post/leetcode-14-longest-common-prefix/</link>
      <pubDate>Wed, 04 May 2022 13:10:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-14-longest-common-prefix/</guid>
      <description>这道题是简单难度的题目，本来我准备跳过这道题目的，但是看了另一篇博客，里面给出了很多种可选的解决方案，每一种解决方案体现的思路还是很不错的。
实现一个函数来计算一组字符串中的公共最长前缀字串。如果没有找到最长公共字串，那么直接返回空串。
示例 示例 1:
输入: strs = [&amp;#34;flower&amp;#34;,&amp;#34;flow&amp;#34;,&amp;#34;flight&amp;#34;] 输出: &amp;#34;fl&amp;#34; 示例 2:
输入: strs = [&amp;#34;dog&amp;#34;,&amp;#34;racecar&amp;#34;,&amp;#34;car&amp;#34;] 输出: &amp;#34;&amp;#34; 解释: There is no common prefix among the input strings. 限制:
 1 &amp;lt;= strs.length &amp;lt;= 200 0 &amp;lt;= strs[i].length &amp;lt;= 200 strs[i]中仅仅包含英文字母  解决方案 解决方案 1 - 纵向比较 我们将这一组字符串的字符序列一行行排列起来，然后一列一列进行比较，如果某一列字符不匹配，或者某一行字符串用完了，那么这一列之前的字串就是我们要找到最长字串。
class Solution {  public String longestCommonPrefix(String[] strs) {  if(strs == null || strs.</description>
    </item>
    
    <item>
      <title>Integer to Roman</title>
      <link>https://www.tlst.cc/post/leetcode-12-integer-to-roman/</link>
      <pubDate>Wed, 27 Apr 2022 19:59:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-12-integer-to-roman/</guid>
      <description>罗马数字是由七个不同的字母来表示，I, V, X, L, C, D 和 M.
Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
符号 值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 比如，数值2在罗马数字表示法中写作II，12则写作XII，就是简单的10（X）加上2(II)，27写作XXVII，就是20（XX）加上5（V）加上2（II）。
罗马数字通常从大往小写，但是数值4对应的罗马数字不是IIII，而是IV，V前面的I使用来从数值5中减去1来得到4，同理IX表示9。具体规则是
 I（1）可以被放到V（5）和X（10）之前，用来表示4和9 X（10）可以被放到L（50）和C（100）之前，用来表示40和90 C（100）可以被放到D（500）和M（1000）之前，用来标识400和900  给定一个阿拉伯数字，将其转换为对应的罗马数字
Integer to Roman 示例 示例 1:</description>
    </item>
    
    <item>
      <title>Container With Most Water</title>
      <link>https://www.tlst.cc/post/leetcode-11-container-with-most-water/</link>
      <pubDate>Tue, 26 Apr 2022 21:05:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-11-container-with-most-water/</guid>
      <description>给定一个数组里面包含n个数字，这n个数字分别表示n个柱子的高度。
我们选定任意两根柱子，配合x轴，我们都能够组合成一个容器，找到所有柱子中任意两个组合所能组成的容器中，能够装水最多的那个，返回最大的容积。
注意，你不能倾斜容器。
Container With Most Water 示例 示例 1:
输入: height = [1,8,6,2,5,4,8,3,7] 输出: 49 解释: 这一组数字表示的柱子中，能够组成的最大容器是第二根柱子和最后一根柱子，整个容器的宽度是7，高度是7，最大容积是49 Example 2:
输入: height = [1,1] 输出: 1 限制条件:
 n == height.length 2 &amp;lt;= n &amp;lt;= 105 0 &amp;lt;= height[i] &amp;lt;= 104  解决方案 解决方案 1 - 暴力破解 对于每一根柱子，我们可以遍历右边的所有柱子，然后计算出所有可能的组合对应的所有容积，然后就可以找到容积最大的那一个。示例代码如下。
class Solution {  public int _maxArea(int[] height) { //超出时间限制  int maxArea = 0;  for(int index = 0;index &amp;lt; height.</description>
    </item>
    
    <item>
      <title>Regular Expression Matching</title>
      <link>https://www.tlst.cc/post/leetcode-10-regular-expression-matching/</link>
      <pubDate>Sun, 24 Apr 2022 21:05:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-10-regular-expression-matching/</guid>
      <description>初次看到这个题目时，给定测试用例，脑子倒是能够很快计算出是否匹配，但是具体怎么通过代码来进行实现却是一时间没太想清楚。后面看了很多的解决方案，大多数解决方案思路的话基本都是动态规划，此外也了解到一个FAM，有限自动机的概念，这个概念在实现正则表达式时好像还蛮有用的。
给定一个字符串S和一个模式P，实现一个正则匹配，此处我们仅需要支持.和*。其中，.匹配任意字符，*匹配零次或者多次前面的元素。注意此处是匹配，不是查找，也就是我们的模式必须恰好匹配整个字符串。
Regular Expression Matching 示例 1:
输入: s = &amp;#34;aa&amp;#34;, p = &amp;#34;a&amp;#34; 输出: false 解释: 模式只能匹配字符串中的一个字符 示例 2:
输入: s = &amp;#34;aa&amp;#34;, p = &amp;#34;a*&amp;#34; 输出: true 解释: *表示匹配前面这个元素一次或者多次，所以我们可以匹配a两次 示例 3:
输入: s = &amp;#34;ab&amp;#34;, p = &amp;#34;.*&amp;#34; 输出: true 解释: &amp;#34;.*&amp;#34;意味着我们可以匹配任意字符多次 限制条件:
 1 &amp;lt;= s.length &amp;lt;= 20 1 &amp;lt;= p.</description>
    </item>
    
    <item>
      <title>Reverse Integer</title>
      <link>https://www.tlst.cc/post/leetcode-7-reverse-integer/</link>
      <pubDate>Sat, 23 Apr 2022 18:57:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-7-reverse-integer/</guid>
      <description>给定一个32位的整数，以十进制表示，返回将其所有数字位翻转之后得到的新的数值，如果由于翻转导致数字溢出，那么返回0。此处假定我们使用的系统不支持64位的整数。
Reverse Integer 示例 示例 1:
输入: x = 123 输出: 321 示例 2:
输入: x = -123 输出: -321 示例 3:
输入: x = 120 输出: 21 限制条件:
 -2 ^ 31 &amp;lt;= x &amp;lt;= 2 ^ 31 - 1  解决方案 解决方案 1 让我们再次回顾题目，整个翻转过程其实并不复杂，但是唯一需要注意的就是，我们可能发生溢出。
比如假定我们使用的不是32位整数，而是八位整数，其范围在[-128 ~ 127]之间。那么当我们尝试对这个范围内的一些整数进行翻转时可能会溢出，比如127，翻转之后是721，显然它已经远远超过了8位整数所能表示的范围。
那么我们如何检测是否发生了溢出呢？让我们看一下整个翻转流程</description>
    </item>
    
    <item>
      <title>Zigzag Conversion</title>
      <link>https://www.tlst.cc/post/leetcode-6-zigzag-conversion/</link>
      <pubDate>Sat, 23 Apr 2022 18:44:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-6-zigzag-conversion/</guid>
      <description>我们来定义一个zigzag模式，给定一个字符串，比如PAYPALISHIRING，特定条件下，它的zigzag模式为PAHNAPLSIIGYIR，这是我们将原字符串按照一定的规则打破重组之后得到的。
具体规则是，首先将这个字符串中的各个字符按照英文字母N的书写顺序在特定的行数限制下进行排列，然后我们收集每一行的字符，并按照行从上往下将各行中收集到的字符串拼接成一个新的字符串。
比如，对于字符串PAYPALISHIRING，首先按照字母N的书写顺序在三行上进行重新排列，将得到
P A H N A P L S I I G Y I R 然后我们将每一行上的字符收集起来，得到
PAHN APLSIIG YIR 并按照从上往下的顺序将多行收集到的字符串拼接成一个新的字符串PAHN + APLSIIG + YIR =&amp;gt; PAHNAPLSIIGYIR。
同理，如果行数为4，那么重新排列之后是
P I N A L S I G Y A H R P I 重新收集拼接之后将会是PIN + ALSIG + YAHR + PI + =&amp;gt;PINALSIGYAHRPI。</description>
    </item>
    
    <item>
      <title>Longest Palindromic Substring</title>
      <link>https://www.tlst.cc/post/leetcode-5-longest-palindromic-substring/</link>
      <pubDate>Thu, 21 Apr 2022 12:01:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-5-longest-palindromic-substring/</guid>
      <description>给定一个字符串，返回其最长回文字串。
The Longest Palindromic Substring 示例 示例 1:
输入: s = &amp;#34;babad&amp;#34; 输出: &amp;#34;bab&amp;#34; 解释: &amp;#34;aba&amp;#34;也是一个正确的答案 示例 2:
输入: s = &amp;#34;cbbd&amp;#34; 输出: &amp;#34;bb&amp;#34; 限制条件:
 1 &amp;lt;= s.length &amp;lt;= 1000 字符串中仅仅包含数组和字母  解决方案 对于这道题目，leetcode自己给出了五个解决方案，这里我们选择其中两个解决方案来进行分析。
解决方案 1 - 动态规划 我们前面刚好写了一篇关于动态规划的文章，感兴趣的同学可以先看看这篇文章 - 动态规划的系统性方法。接下来我们就按照这篇文章里面的阐述的方法来对这个问题进行分析。
让我们回顾下动态规划的系统性方法
* 首先，问你自己一个问题，我真的需要使用动态规划解决这个问题吗或者说我真的可以用动态规划解决这个问题吗  * 定义我们的状态 * 定义我们的递归关系，或者说是状态迁移方程 * 列出所有状态转换及其各自状态迁移的条件 * 定义我们的基本情况 * 实现一个朴素的递归解决方案 * 使用自顶向下的方法（Memoization）对我们递归的解决方案进行优化 * 使用自底向上的方法（Tabulation）消除递归的开销 可以用动态规划解决这个问题吗 这个问题同样是让我们基于一个特定的条件求解一个最大的结果，条件是回文序列，结果是最大字串长度。我们可以看出这是一个最优解问题，那么它是否包含一个优化结构呢？</description>
    </item>
    
    <item>
      <title>Median of Two Sorted Arrays</title>
      <link>https://www.tlst.cc/post/leetcode-4-medianof-two-sorted-arrays/</link>
      <pubDate>Wed, 20 Apr 2022 13:10:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-4-medianof-two-sorted-arrays/</guid>
      <description>给定两个有序的数组nums1和nums2，其对应的元素个数分别为m和n，返回这两个数组的中值。
解决方案总体的时间复杂度不能超过O(log (m+n))。
Median of Two Sorted Arrays 示例 示例 1:
输入: nums1 = [1,3], nums2 = [2] 输出: 2.00000 解释: 合并后的数组是[1,2,3]，中值是2. 示例 2:
输入: nums1 = [1,2], nums2 = [3,4] 输出: 2.50000 解释: 合并后的数组是[1,2,3,4]，中值是(2 + 3) / 2 = 2.5. 限制条件:
 nums1.length == m nums2.length == n 0 &amp;lt;= m &amp;lt;= 1000 0 &amp;lt;= n &amp;lt;= 1000 1 &amp;lt;= m + n &amp;lt;= 2000 -106 &amp;lt;= nums1[i], nums2[i] &amp;lt;= 106  解决方案 解决方案 1 - 合并数组 如果我们抛开时间复杂度的限制，我们将两个数组进行合并，然后再计算中值就比较简单了。但是整体的空间复杂度是O(m + n)，时间复杂度是O(m + n)。</description>
    </item>
    
    <item>
      <title>Longest Substring Without Repeating Characters</title>
      <link>https://www.tlst.cc/post/leetcode-3-longest-substring-without-repeating-characters/</link>
      <pubDate>Wed, 20 Apr 2022 09:13:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-3-longest-substring-without-repeating-characters/</guid>
      <description>给定一个字符串，找到它里面不包含重复字符的最长的字串。
Longest Substring Without Repeating Characters 示例 示例 1:
输入: s = &amp;#34;abcabcbb&amp;#34; 输出: 3 解释: 满足条件的最长字串是&amp;#34;abc&amp;#34;，字符串长度是3 示例 2:
输入: s = &amp;#34;bbbbb&amp;#34; 输出: 1 解释: 满足条件的最长字串是&amp;#34;b&amp;#34;，长度是1 示例 3:
输入: s = &amp;#34;pwwkew&amp;#34; 输出: 3 解释: 满足条件的最长字串是&amp;#34;wke&amp;#34;，长度是3 Constraints:
 0 &amp;lt;= s.length &amp;lt;= 5 * 10000 字符串可能包含英文字母，数字，特殊符号以及空格  解决方案 解决方案 1 - BitSet class Solution {  public int lengthOfLongestSubstring(String s) {  java.</description>
    </item>
    
    <item>
      <title>Add Two Number</title>
      <link>https://www.tlst.cc/post/leetcode-2-add-two-number/</link>
      <pubDate>Tue, 19 Apr 2022 17:44:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-2-add-two-number/</guid>
      <description>给定两个非空的链表，分别代表两个非负整数，链表的每一个节点代表整数的一位数字，数字是按照倒序存储的。请对这两个数字进行求和，并将结果按照同样的格式进行返回。
此处我们假定，这两个数字不包含任何前置0，当然了除了数字0本身。
Add Two Number 示例 示例 1:
输入: l1 = [2,4,3], l2 = [5,6,4] 输出: [7,0,8] 解释: 342 + 465 = 807. 示例 2:
输入: l1 = [0], l2 = [0] 输出: [0] 示例 3:
输入: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] 输出: [8,9,9,9,0,0,0,1] Constraints:
 每一个数字的位数也即每个链表的长度限制在范围[1, 100]. 0 &amp;lt;= Node.</description>
    </item>
    
    <item>
      <title>LeetCode</title>
      <link>https://www.tlst.cc/post/leetcode/</link>
      <pubDate>Tue, 19 Apr 2022 12:44:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode/</guid>
      <description>之前得空在leetcode上面刷了一段时间的题目，前前后后一共有三百多道题目吧。先是把简单难度的题目中大家评价还不错的题目都刷了一遍，然后是leetcode前100的题目有些之前没覆盖到的也捡起来刷了一下，这些题目甚至还试了一下多种可能的解决方案。
前期刷题的时候，其实只是自己实现了一下，整个的解决方案比较繁琐，没有花时间在评论区多看一看。
其实当我仔细看了有些大佬的解决方案之后，有时候甚至会产生一些羞愧感，明明相似的题目我之前做过，为什么现在又不会了等等。
在刷前一百的题目的时候，我有仔细对比自己的解决方案和其他人提供的解决方案有什么不同，事实证明，在评论区泡一泡还是有不少收获的。所以现在又回过头来看下之前刷的题目，然后慢慢整理一遍。
列表  1 - Two Sum 2 - Add Two Number 3 - Longest Substring Without Repeating Characters 4 - Median of Two Sorted Arrays 5 - Longest Palindromic Substring 6 - Zigzag Conversion 7 - Reverse Integer 10 - Regular Expression Matching 11 - Container With Most Water 12 - Integer to Roman 14 - Longest Common Prefix 15 - 3Sum  </description>
    </item>
    
    <item>
      <title>Two Sum</title>
      <link>https://www.tlst.cc/post/leetcode-1-two-sum/</link>
      <pubDate>Tue, 19 Apr 2022 12:44:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-1-two-sum/</guid>
      <description>Two Sum 概述 给定一个整数数组和一个目标值，在数组中找到两个数字，满足这两个数字之和等于目标值，返回这两个数字的索引。
此处我们假定这个数组中只有一个组合满足上述条件，此外，你不能使用同一个数字两次。
你可以以任意顺序返回组合的索引。
示例 1:
输入: nums = [2,7,11,15], target = 9 输出: [0,1] 解释: Because nums[0] + nums[1] == 9, we return [0, 1]. 示例 2:
输入: nums = [3,2,4], target = 6 输出: [1,2] 示例 3:
输入: nums = [3,3], target = 6 输出: [0,1] 限制条件:</description>
    </item>
    
    <item>
      <title>Java内存模型</title>
      <link>https://www.tlst.cc/post/java-concurrent-programming-02/</link>
      <pubDate>Wed, 30 Mar 2022 12:44:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/java-concurrent-programming-02/</guid>
      <description>在我们学习操作系统时，有一个章节会讲数据存储相关的的内容，那个经典的金字塔模型。哈哈，又一个Trade off 的完美诠释。这个金字塔模型中指出，通常我们可以很容易地获得一些存储设备，其数据容量大，成本低廉，但是访问速度较慢，比如我们常见的磁盘，甚至可以扩展到网盘。我们还有一些存储介质，其容量非常小，小到当我们使用这类存储介质所能提供的空间时，不得不小心翼翼，而且此类介质一般价格十分高昂，但是由于这类存储介质相对来说更加靠近我们的计算单元，所以其访问速度非常非常快，几乎可以忽略不记，比如我们的寄存器。
在我们讨论这个抽象的金字塔概念之前，让我们先看一个生活中比较常见的例子。比如你是一个木匠，你准备做点科研，造个什么木制品出来，这个作品相当精妙，以至于需要十几种甚至更多的工具来帮助你完成，假定这些工具目前放在你的车库。
现实中，当你用工具的时候你并不会总是去车库找工具，你可能会先找一个小盒子将你认为在不远的将来你可能会用到的工具先一次性取出来。此外你甚至不会说是每次用什么工具都会去盒子里面找一下，一般你总会保证伸手就够得着的地方有最近需要使用的那么几件工具，此外，你的手上可能握着正在使用的一到两件工具。你会发现，从车库到盒子到手够得着的位置再到你的手上，能够维护的工具数量越来越少，车库总是能够放上很多的工具，箱子里面可能有十几个，在身边就能够着的区域可能就只能放四五个了，手上可能拿两个工具已经是极限了。
但是不可否认，这的确会对你的工作效率产生很大的提升，其实这得益于两个定理，第一个，现在正在使用的工具在不远的未来更可能会被用到，和这个很好理解，同一个工具你可能会用很长一段时间；一个工具被用到，对于它来说比较接近，比如功能相似的一些工具在不远的将来更有可能被用到，比如各种型号的木头抛光器。
当然了，有时候你会把手上的工具换下来，然后可能会发现工具没在旁边，你可能还是会去翻盒子，如果盒子里面找不到，比如你压根儿就忘了从车库里取出来，你那么你就不得不跑到车库里面再取一遍了。而且如果还有其他人也依赖于这个车库来获取工具的话，你可能还得及时的将工具还回去，如果每次用完就还回去，你可能会在车库和工作室之间跑来跑去，很影响工作效率；但是如果每次都是到最后作品完成再还回去，可能其他人要抱怨了。聪明的你应该又看到另一个** Trade off**的影子了吧，哈哈。
让我们再回到之前的金字塔底部，我们现在好像瞥见到了两个极端，一个是金字塔的底部，另一个则是金字塔的顶端。便宜，大容量但是速度慢；速度足够快但是价格高昂且容量很小。好在金字塔不止有底部和顶端，它还有中间的部分，这也是我们的Trade off策略得以游走的空间。我们从金字塔的最底部慢慢向上攀爬探索：
  越过磁盘，首先我们可能接触的内存，虽然断电后数据就会丢失，但是其访问速度相较于磁盘已经有了质的提升，当然了，相对于磁盘，其价格更高，容量也要小很多，在1TB的固态硬盘充斥在人们的生活中时，我们通常可以操作的内存空间一般只有8G，16G等；很多的操作系统也通过虚拟内存突破了物理内存的限制，所以一般16G的内存对于绝大多数人来说都已经足够了。
  我们继续向上攀爬，此时我们会遇到称为高速缓存的东西，一般有两级，我们称之为二级缓存和以一级缓存，实际上我们的CPU尝试加载数据时，并不会直接和我们的内存打交道，我们首先会将需要访问的内存连同周边临近的内存区域先加载到二级缓存中，然后再加载一部分到一级缓存中。现在当CPU尝试去加载数据的时候，花在IO上的时间就很短了。
  然后就是寄存器了，如果你写过汇编或者有看过反编译后的Java的字节码指令，你可能会看到，我们是如何精细地一个一个存储单元的进行访问和管理的。空间很小，但是因为他们是最接近CPU的位置，它们的存在让我们的指令序列得以流畅的执行，而不必每次都花费大量时间等待IO。
  Java作为一门编程语言以及一个平台，其底层实现的时候，其实也逃不掉这些模式的束缚。只不过我们上面讨论的是硬件资源上的一些Trade off，Java内存模型是在这个基础之上又进行了一层抽象，但是其内在原理还是相通的。
本系列文章在编写时大量参考了《Java并发编程艺术》一书，原书将Java内存模型放在第三章，将Java语言中的一些特性以及实现原理，比如synchronized，volatile等关键字放在第二章。当我在准备第二篇文章的时候，老师感觉写起来不是很顺畅，因为里面有很多的概念其实是依赖于Java内存模型中的很多内容的。所以就调整了一下顺序，将JMM提到前面来写一下。
目录  Java内存模型  Java内存模型的抽象结构 指令重排序  处理器指令重排序 内存屏障 Happens-before原则 重排序  数据依赖性 as-if-serial语义 程序顺序规则 重排序对多线程的影响   顺序一致性  数据竞争与顺序一致性 顺序一致性内存模型 同步程序的顺序一致性效果 未同步程序的执行特性   Volatile的内存语义 Volatile写-读建立的happens-before关系 volatile内存语义的实现 锁的内存语义  锁的释放与获取 锁内存语义的实现 ReentrantLock-公平锁 ReentrantLock-非公平锁     Concurrent包的实现 final域的内存语义  final域的重排序规则  写final域的重排序规则 读final域的重排序规则 final域为引用类型     happens-before  Java内存模型的设计 happens-before的定义 happens-before规则   双重检查锁&amp;amp;amp;延迟初始化  基于volatile的解决方案 基于类初始化的解决方案   总结  处理器的内存模型 各种内存模型之间的关系 Java内存模型的内存可见性保证      Java内存模型  在并发编程中，我们有两个问题需要解决，当多个线程共同合作完成一个或者多个特定问题时，我们定义好线程之间如何进行通信以及如何进行同步的。通信是指线程之间如何交换信息，包括获取处理的入参输出处理的结果等等。线程之前通信的方式两种，消息传递和共享内存。</description>
    </item>
    
    <item>
      <title>Java并发机制的底层实现原理</title>
      <link>https://www.tlst.cc/post/java-concurrent-programming-03/</link>
      <pubDate>Wed, 30 Mar 2022 12:44:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/java-concurrent-programming-03/</guid>
      <description>无规矩不成方圆，为了获得并发编程带来的好处，我们需要定义一套严谨的控制机制。只有在这套机制的控制下，JVM才能够按照预期执行我们的字节码，只有了解这套机制，我们才能够编写出正确的代码得到正确的结果。
目录 Java并发机制的底层实现原理 Java为了方便编程人员进行实现，其暴露了很多的关键字以及Api，比如synchronized，volatile以及各种Lock。我们很容易使用这些关键字以及Api实现出一些线程安全的代码，但是我们不能止步于此，要知道在软件开发的世界里，你可以在各种各样的地方找到一些Trade off的完美诠释，同样在并发编程时，相对简单的一个实现方式通常意味着你可能牺牲了一些性能，换句话说，再花同样的时间你可能能够做的更好，在保证线程安全的情况下还能够让你的程序仍然高效的执行。。所以让我们一起看下这些特性如何使用以及其背后的原理吧。
第一个关键字 - volatile volatile，这个单词直接翻译过来是易挥发的，比如酒精，汽油等物质的挥发性。在计算机相关的属于里面，或者说是在Java语言里面，通常我们会将其翻译成易失的。我猜之所以使用这个单词是因为所有被volatile关键字标注的变量其引用的内存区域需要保证一种可见性，而JVM通过一种机制总是将最新的内容写到主存中并且也总是从主存中读取数据来实现这个，所以对于工作内存中的值，其总是很容易miss，所以才有了这么一个定义。
这一段话里面可能涉及了很多的概念，其中非常重要的有Java内存模型相关的内容，其会在后面的文章中被覆盖到，如果暂时不清楚的话可以先跳到内存模型相关的文章中了解对应的内容。
待补充</description>
    </item>
    
    <item>
      <title>并发编程的挑战</title>
      <link>https://www.tlst.cc/post/java-concurrent-programming-01/</link>
      <pubDate>Mon, 28 Mar 2022 19:06:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/java-concurrent-programming-01/</guid>
      <description>在讨论并发编程的挑战之前，我想要先和大家一起回顾下并发和并行的概念，这两个概念从字面上看上去其实非常的相似，很容易搞混。
首先两者中都有一个并字，我们姑且先讲并翻译为同时。
如此一来，那么并发也就是同时发生，其实更加准确一点来说应该称之为同时发生一样，什么意思呢，在单核处理器时代，分时系统通过将同一个CPU核心的执行时间进行分片，然后将时间片依次分给多个执行单元，然后在用户的感知层面达到一种每一个执行单元都在同时发生一样，比如多个应用程序同时为我们的用户提供服务。
而并行则是一个相对来说更晚一些的概念，当摩尔定律慢慢走向终结，CPU的生产厂商无法在单个的芯片上放置更多的晶体管后，他们开始转变思路，不再致力于如何在芯片上放更多的晶体管，而是为一台计算机配置更多的核心来达到同样的目的，当计算机拥有更多核心之后，我们用另外一种方式更加高效的利用计算机的算力，那就是并行。
在此之前，我们同一时间最多只能有一个执行单元被执行，其实换句话说同一时间只会有一个线程在执行，也只有一个进程在执行，即使这个进程被拆分为多个线程。但是在拥有多核的构造之后，我们不光能够继续拥有并发带给我们的好处，此外我们甚至能让同一进程的多个可执行单元，也就是多个线程在分别在多个核心上执行。总而言之，并发就是多个执行单元在同一个核心上交替执行，并行则是多个执行单元在多个核心的每一个核心上并发。
我们通过一张图片看下两者的区别，Erlang发明者Joe Armstrong通过一个咖啡机的例子生动的向大家解释了并行和并发之间的区别。
目录  并发编程的挑战  上下文切换  多线程一定快吗 我们如何减少上下文切换呢   死锁  如何避免死锁   资源限制  什么是资源限制 资源限制带来的问题 如何解决资源限制问题 在资源限制的基础上进行并发编程      并发编程的挑战  前面我们简单讲了一下并发是什么。的确，并发的目的就是为了让我们的程序运行的更快，但是并不是启动的线程越多我们的程序执行的就越快，并发时，多个可执行单元之间进行切换时会有性能开销，多个线程访问一些临界资源时也会有各种竞争条件，此外我们还会受限于硬件和软件的资源限制。
上下文切换  我们先考虑单核的情况，当我们在单核上执行多线程时，CPU通过给每个线程分配CPU时间片实现这个机制。时间片是CPU分给各个线程的执行时间，它通常比较短，比如几十毫秒，然后CPU通过不停的切换线程执行，让用户感觉多个线程是在同时执行的。
CPU的确通过时间片分配算法来实现了循环执行任务，当前任务执行一个时间片之后会切换到下一个任务，但是在切换之前，我们需要保存上一个任务的执行状态，只有这样，当下一次切换回这个任务时，我们才能够重新加载这个任务的状态并继续执行。而这个保存任务状态然后再加载并执行的过程就是上下文切换。
就比如我们在和一个人聊天的时候，突然另一个电话打进来了，我们可能需要先和当前这位聊天的小伙伴说一声抱歉，然后记住你们目前讨论的问题是什么，然后转而先去接这个临时打进来的电话，等这个电话结束，我们可能会再找到之前聊天的那个小伙伴，继续之前讨论的话题。显然，这样的切换是会影响到你们沟通的效率的，你应该经常问道或者听别人问道过，&amp;ldquo;诶，我们刚刚讲到哪儿了？&amp;quot;，同理，这样的上下文切换也会影响多线程的执行速度。
多线程一定快吗  事实上，当我们的计算量小于某一个量级时，拆分更多的线程可能最终的效率还不如让整个计算过程串行执行。因为频繁的上下文切换反而浪费了更多时间，这些时间最终随着线程数的增加反而超过了多核并行计算带来的收益。我们后面也会讲到，如何基于IO密集型还是CPU密集型的处理流程来设置恰当的线程数量来保证我们的程序有更好的性能。
我们如何减少上下文切换呢  减少上下文切换的方式有很多，比如适当控制线程数量，使用CAS算法，无锁并发编程以及协程等。
 控制线程数量 - 避免创建大量不需要的线程，比如整个任务是CPU密集型的，明明CPU已经满负荷运行了，已经以最大的计算能力处理我们的数据了，此时我们创建过多的线程，可能会适得其反，因为这时候CPU不光要忙着计算最终的结果，还需要频繁的进行上下文切换，反而拖慢了整体的效率。 CAS算法 - 全称是Compare And Swap，使用CAS算法时，我们不会尝试去获取锁，线程也就不会阻塞，也意味着我们不会失去对CPU的使用权，那么我们也就不需要进行上下文切换了。 无锁并发编程 - 多线程竞争锁时，会引起上下文切换，所以如果我们能够使用一些办法来避免使用锁或者避免锁竞争的话，就可以避免切换。比如Java 5引入的ConcurrentMap的概念以及其实现ConcurrentHashMap，就可以通过使用分段锁来提高并发度，从而避免大量的锁竞争。 协程 - 在单线程中实现多任务的调度，并在单线程里维持多个任务的切换。  死锁  当我们面对并发编程时可能遇到的竞争条件时，我们有时需要使用锁来对资源的访问进行控制，否则我们程序的执行结果就可能是错误的，花费了大量的算力最终得到的却是一个没有意义的结果。</description>
    </item>
    
    <item>
      <title>动态规划的系统性方法</title>
      <link>https://www.tlst.cc/post/system-approach-to-dp/</link>
      <pubDate>Fri, 25 Mar 2022 20:29:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/system-approach-to-dp/</guid>
      <description>其实很早就想要写一篇动态规划相关的文章，把这个非常棒的算法或者说是一种问题思考方式推荐给更多的人，不论你是程序员还是其他任何职业的从业人员，了解动态规划都会对你或者说你看待一个问题的方式或多或少产生一些影响，因为它真的太强大了。
那么为什么我会这么觉得呢?
第一，动态规划几乎可以说是分治在现实世界里面最优雅的一种表达方式。当我们面对一个非常复杂的问题时，如果这个问题能够划分为子问题并逐个击破，那么此时不用想太多，动态规划大概率是解决这个问题的一个最好的工具了，不论是指导你对这个问题进行快速的分析还是最终作为实际的解决方案，动态规划绝对会让你的眼前一亮。
第二，动态规划不会止步于问题分析以及给出一个递归的解决方案。的确，当我们使用动态规划时，当我们明确了我们的状态以及状态迁移方程，我们很容易得到一个基于递归的解决方案。这是动态规划的一大优点所在，即你不需要将一整个问题放到你的脑海中完完整整的想清楚，你只需要瞥见其中的规律，便可以快刀斩乱麻，轻松地解决一个非常复杂的问题；但是递归虽好，如果有时候使用不当，你的程序可能需要大量的资源，执行大量的计算，花费更多的时间才能得到最终的结果；好在动态规划并没有止步于仅仅给出一个递归的解决方案，除此之外，我们只要使用一些其他的方法或者依赖一些恰当的数据结构，就能够得到一个高效到令人拍案叫绝的解决方案。
初次接触到动态规划时，我甚至都不知道自己接触了这个概念，其实就是大家可能经常接触到的一个数学问题，斐波那契数列。
 斐波那契数列（Fibonacci sequence），又称黄金分割数列，因数学家莱昂纳多·斐波那契（Leonardo Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子 数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波那契数列以如下被以递推的方法定义：F(0)=0，F(1)=1，F(n)=F(n - 1)+ F(n - 2)（n ≥ 2，n ∈ N*）
 你可能会问道，这个斐波那契数列和动态规划又有什么关系呢，哈哈，的确，乍一看，可能这两者之间并没有太大联系，不过这并不奇怪，主要是因为我们已经跳过了动态规划的部分，转向了当我们使用动态规划给这个问题求解时所得到的最终的解决方案，所以我们已经看不到动态规划的影子了，也就无从探究它的魅力了。
那么怎么办呢，我们可能从这个问题的源头开始说起，我这里不会举这个百度百科或者维基百科上出现的兔子问题，我所要想你展示的是另一个非常有趣的问题&amp;ndash;爬楼梯。
 爬楼梯问题，假设有十级楼梯，你每次移动时，要么移动一级台阶，要么移动两级台阶，请问从楼梯的底部到顶部你一共有多少种可能的方式？
 当我们拿到这个问题时，我们的大脑可能会不由自主的开始枚举所有可能的结果，比如每一步都只向上移动一级台阶是一种可能的走法，每一步都向上移动两级台阶是一种走法，前面四步每一步都移动两级台阶，然后第五步第六步分别移动以及台阶又是一种走法。如此循环往复尝试罗列所有的可能的结果，但是你很快就会发现，想要罗列出所有结果对你来说太难了，此外你也应该已经注意到了，现在还仅仅是十几台阶，如果是二十级三十级甚至更多，使用这种枚举的方式几乎是不可能行得通的。
此时，动态规划的思想就很容易应用到这个问题上了。来，让我们转换一下思路，加入你现在只剩最后一次移动就到达第十级阶梯了，那么你可能的情况是什么呢，你会发现此时只会有两种结果，那就是你要么在第九级阶梯，此时你向上移动一级阶梯就可以到达终点了；要么你在第八级阶梯，此时你向上移动两级阶梯同样可以到达终点。那么换句话说，你想要到达终点，就必须先到达第八级阶梯或者第九级阶梯，也意味着，走到终点的可能的走法等价于走到第八级阶梯的走法加上走到第九级阶梯的走法。同理，想要到达第九级阶梯的走法又等价于走到第七级阶梯的走法加上走到第八级阶梯的走法。一次类推，我们可以得到一个方程式f(n) = f(n - 1) + f(n - 2)。此时我们暂时不考虑所谓边界条件。
OK我们此时已经拿到了一个所谓的方程f(n) = f(n - 1) + f(n - 2)，此时你可能又会尝试调转你的脑细胞还是进行计算了。f(10) = f(9) + f(8)、f(9) = f(8) + f(7) =&amp;gt; f(10) = f(8) + f(7) + f(8).</description>
    </item>
    
    <item>
      <title>基于Hugo &amp; Nginx搭建博客</title>
      <link>https://www.tlst.cc/post/blog-with-go-hugo-nginx/</link>
      <pubDate>Mon, 21 Mar 2022 20:12:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/blog-with-go-hugo-nginx/</guid>
      <description>本文中，我将会简单讨论什么是静态页面生成，简单了解几种比较流行的静态页面生成器并选取其中一种名叫Hugo的静态页面生成器进行详细介绍。 事实上，您现在所看到的的内容正是基于Hugo以及其最受欢迎的主题Log Book所构建的。
目录  什么是静态网站生成 为什么仍然需要静态网站 常见的一些静态页面生成器 Hugo / Jekyll / Hexo 准备工作  第一步 - 安装Go 第二步 - 安装Hugo 第三步 - 让我们简单认识一下Hugo CLI  hugo命令 草稿 / 未来 / 过期内容 hugo server / 热加载     开始网站搭建  第一步 - 创建一个网站 第二步 - 为你的网站添加主题 第三步 - 为你的网站添加一些内容 第四步 - 启动Hugo Server   部署我们的网站到服务器  第一步 - 换一个好看的主题 第二步 - 构建我们需要部署的静态资源 第三步 - 推送文件到远程仓库 第四步 - 使用Nginx部署网站   踩坑记录  什么是静态网站生成  所谓静态网站生成或者静态页面生成是指一种处理过程，其能够静态地生成一个网站，这个网站可能由一系列的静态的HTML页面组成。 通常，我们在本地环境通过这种流程生成静态的页面，然后我们将其上传至对应的服务器进行发布，当用户请求对应的资源时，我们直接将这些资源返回给用户进行展示。 整个过程中，不需要任何的服务器端渲染或者处理，客户端和服务器也不会有其他形式的数据传输，仅仅专递静态资源文件。</description>
    </item>
    
  </channel>
</rss>
