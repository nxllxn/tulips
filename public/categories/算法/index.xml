<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法 on Tulips</title>
    <link>https://www.tlst.cc/categories/%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 算法 on Tulips</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Copyright @ 2022 郁金香啊</copyright>
    <lastBuildDate>Tue, 17 May 2022 19:15:33 +0800</lastBuildDate><atom:link href="https://www.tlst.cc/categories/%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Merge k Sorted Lists</title>
      <link>https://www.tlst.cc/post/leetcode-23-merge-k-sorted-lists/</link>
      <pubDate>Tue, 17 May 2022 19:15:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-23-merge-k-sorted-lists/</guid>
      <description>给定n个按照升序排序的链表，将这n个链表合并成一个升序排序的链表并返回。
示例 示例 1:
输入: lists = [[1,4,5],[1,3,4],[2,6]] 输出: [1,1,2,3,4,4,5,6] 解释: 给定的三个链表是[1-&amp;gt;4-&amp;gt;5, 1-&amp;gt;3-&amp;gt;4, 2-&amp;gt;6]合并之后的结果是1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4-&amp;gt;5-&amp;gt;6 示例 2:
输入: lists = [] 输出: [] 示例 3:
输入: lists = [[]] 输出: [] 限制条件:
 k == lists.length 0 &amp;lt;= k &amp;lt;= 104 0 &amp;lt;= lists[i].length &amp;lt;= 500 -104 &amp;lt;= lists[i][j] &amp;lt;= 104 lists[i] is sorted in ascending order.</description>
    </item>
    
    <item>
      <title>Valid Parentheses</title>
      <link>https://www.tlst.cc/post/leetcode-22-generate-parentheses/</link>
      <pubDate>Mon, 16 May 2022 20:13:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-22-generate-parentheses/</guid>
      <description>给定N组括号，实现一个函数以生成所有可能的有效的括号组合。
示例 示例 1:
Input: n = 3 Output: [&amp;#34;((()))&amp;#34;,&amp;#34;(()())&amp;#34;,&amp;#34;(())()&amp;#34;,&amp;#34;()(())&amp;#34;,&amp;#34;()()()&amp;#34;] 示例 2:
Input: n = 1 Output: [&amp;#34;()&amp;#34;] 限制条件:
 1 &amp;lt;= n &amp;lt;= 8  实现方案 实现方案 1 - 展开 - 错误答案 当我看到这道题目时，我第一个解决方案是对括号进行一层一层的展开，如果我们有一个字符串了，那么再加一组括号的话，要么是在这个字符串的前面加上()，要么是在这个字符串的后面加上()，要么是在前面加上(然后在后面加上).
在数量较少时这样的思路的确能够得到正确的结果，但是括号的组数为4时我们实际得到的结果就已经有些遗漏了。我们无法组装出(())(())这种结果。
我们简单看下四次计算过程。注意我们去掉了重复的结果
() ()() (()) ()()() (()()) ()(()) ((())) (())() ()()()() (()()()) ()(()()) ((()())) (()())() ()()(()) (()(())) ()(())() ()((())) (((()))) ((()))() ((())()) (())()() class Solution {  //(())(()) cannot generate this combination  public List&amp;lt;String&amp;gt; generateParenthesis_wrong(int n) {  LinkedList&amp;lt;String&amp;gt; queue = new LinkedList&amp;lt;&amp;gt;();   queue.</description>
    </item>
    
    <item>
      <title>Valid Parentheses</title>
      <link>https://www.tlst.cc/post/leetcode-20-valid-parentheses/</link>
      <pubDate>Wed, 11 May 2022 19:40:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-20-valid-parentheses/</guid>
      <description>给定一个由&amp;rsquo;(&amp;rsquo;, &amp;lsquo;)&amp;rsquo;, &amp;lsquo;{&amp;rsquo;, &amp;lsquo;}&amp;rsquo;, &amp;lsquo;[&amp;rsquo; and &amp;lsquo;]&amp;lsquo;组成的字符串，判断这个字符串里的括号是否匹配。
示例 示例 1:
输入: s = &amp;#34;()&amp;#34; 输出: true 示例 2:
输入: s = &amp;#34;()[]{}&amp;#34; 输出: true 示例 3:
输入: s = &amp;#34;(]&amp;#34; 输出: false 限制条件:
 1 &amp;lt;= s.length &amp;lt;= 104 字符串只包含字符()[]{}  解决方案 解决方案 1 - 栈 我们将所有的左括号入站，每当遇到右括号，我们判断栈顶的左括号和当前的右括号是否匹配，如果匹配那么就将栈顶的左括号出栈。如果出现不匹配的情况或者遍历结束之后栈不为空，那么这个字符串中的括号序列是不匹配的。
class Solution {  public boolean isValid(String s) { //1）可以加上奇数长度的校验2）遇到(,[,{对应push),],}.</description>
    </item>
    
    <item>
      <title>Remove Nth Node From End of List</title>
      <link>https://www.tlst.cc/post/leetcode-19-remove-nth-node-from-end-of-list/</link>
      <pubDate>Wed, 11 May 2022 19:08:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-19-remove-nth-node-from-end-of-list/</guid>
      <description>给定一个链表，移除这个链表的倒数第n个节点。
示例 示例 1:
输入: head = [1,2,3,4,5], n = 2 输出: [1,2,3,5] 示例 2:
输入: head = [1], n = 1 输出: [] 示例 3:
输入: head = [1,2], n = 1 输出: [1] 限制条件:
 1 &amp;lt;= 链表长度 &amp;lt;= 30 0 &amp;lt;= 节点值 &amp;lt;= 100 1 &amp;lt;= n &amp;lt;= 链表长度  解决方案 解决方案 1 - 双指针 我们假定有快慢两个指针，我们让快指针先走n步，然后再让快慢指针同时向后走，当我们的快指针到达终点的时候，我们的慢指针就刚好处于倒数第n个节点的位置。</description>
    </item>
    
    <item>
      <title>Letter Combinations of a Phone Number</title>
      <link>https://www.tlst.cc/post/leetcode-17-letter-combinations-of-a-phone-number/</link>
      <pubDate>Tue, 10 May 2022 19:45:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-17-letter-combinations-of-a-phone-number/</guid>
      <description>给定一个字符串其包含2到9的数字，返回所有可能的字母组合。此处的字母组合是指使用九键输入法时可能出现的组合。
示例 示例 1:
输入: digits = &amp;#34;23&amp;#34; 输出: [&amp;#34;ad&amp;#34;,&amp;#34;ae&amp;#34;,&amp;#34;af&amp;#34;,&amp;#34;bd&amp;#34;,&amp;#34;be&amp;#34;,&amp;#34;bf&amp;#34;,&amp;#34;cd&amp;#34;,&amp;#34;ce&amp;#34;,&amp;#34;cf&amp;#34;] 示例 2:
输入: digits = &amp;#34;&amp;#34; 输出: [] 示例 3:
输入: digits = &amp;#34;2&amp;#34; 输出: [&amp;#34;a&amp;#34;,&amp;#34;b&amp;#34;,&amp;#34;c&amp;#34;] 限制条件:
 0 &amp;lt;= digits.length &amp;lt;= 4 数字取值范围为[&#39;2&#39;, &#39;9&#39;]  解决方案 解决方案 1 - 队列 其实我们观察下最终结果，给定一个数字的话，我们返回这个数字对应按键上的字母就好了，如果有两个数字的话，我们需要对前一个数字的结果再进行展开，或者说组合。
利用队列我们很容易做到这一点。
import java.util.LinkedList; import java.util.Queue;  class Solution {  public List&amp;lt;String&amp;gt; letterCombinations(String digits) {  LinkedList&amp;lt;String&amp;gt; res = new LinkedList&amp;lt;&amp;gt;();   res.</description>
    </item>
    
    <item>
      <title>3Sum Closest</title>
      <link>https://www.tlst.cc/post/leetcode-16-3-sum-closest/</link>
      <pubDate>Mon, 09 May 2022 20:02:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-16-3-sum-closest/</guid>
      <description>给定一组整数以及一个目标数，找到任意三个数字使得这三个数字之和最接近目标数。返回这三个数字之和。
你可以假定每一个输入仅仅包含一个解。
示例 示例 1:
输入: nums = [-1,2,1,-4], target = 1 输出: 2 解释: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). **示例 2:** 输入: nums = [0,0,0], target = 1 输出: 0 限制条件:
 3 &amp;lt;= nums.length &amp;lt;= 1000 -1000 &amp;lt;= nums[i] &amp;lt;= 1000 -104 &amp;lt;= target &amp;lt;= 104  解决方案 解决方案 1 - 排序 &amp;amp; 双指针 根据上一道题目的解决方案，我们很容易得到这道题目的解决方案，思路基本相似，唯一需要调整的就是记录下最小的差别以及得到最小差别时的总和。</description>
    </item>
    
    <item>
      <title>3Sum</title>
      <link>https://www.tlst.cc/post/leetcode-15-3-sum/</link>
      <pubDate>Sat, 07 May 2022 21:16:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-15-3-sum/</guid>
      <description>给定一组整数，返回所有可能的三元组[nums[i], nums[j], nums[k]]，其中i != j, i != k, j != k，使得三元组之和等于零。
此处要求返回的三元组不能包含重复的组合。
示例 示例 1:
输入: nums = [-1,0,1,2,-1,-4] 输出: [[-1,-1,2],[-1,0,1]] 示例 2:
输入: nums = [] 输出: [] 示例 3:
输入: nums = [0] 输出: [] 限制条件:
 0 &amp;lt;= nums.length &amp;lt;= 3000 -105 &amp;lt;= nums[i] &amp;lt;= 105  解决方案 解决方案 1 - 排序 + 二分查找 此处题目要求找到三个数字，其和为零，我们可以先找两个数字，比如m和n，然后再找到第三个数字其等于0 - m - n。</description>
    </item>
    
    <item>
      <title>Longest Common Prefix</title>
      <link>https://www.tlst.cc/post/leetcode-14-longest-common-prefix/</link>
      <pubDate>Wed, 04 May 2022 13:10:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-14-longest-common-prefix/</guid>
      <description>这道题是简单难度的题目，本来我准备跳过这道题目的，但是看了另一篇博客，里面给出了很多种可选的解决方案，每一种解决方案体现的思路还是很不错的。
实现一个函数来计算一组字符串中的公共最长前缀字串。如果没有找到最长公共字串，那么直接返回空串。
示例 示例 1:
输入: strs = [&amp;#34;flower&amp;#34;,&amp;#34;flow&amp;#34;,&amp;#34;flight&amp;#34;] 输出: &amp;#34;fl&amp;#34; 示例 2:
输入: strs = [&amp;#34;dog&amp;#34;,&amp;#34;racecar&amp;#34;,&amp;#34;car&amp;#34;] 输出: &amp;#34;&amp;#34; 解释: There is no common prefix among the input strings. 限制:
 1 &amp;lt;= strs.length &amp;lt;= 200 0 &amp;lt;= strs[i].length &amp;lt;= 200 strs[i]中仅仅包含英文字母  解决方案 解决方案 1 - 纵向比较 我们将这一组字符串的字符序列一行行排列起来，然后一列一列进行比较，如果某一列字符不匹配，或者某一行字符串用完了，那么这一列之前的字串就是我们要找到最长字串。
class Solution {  public String longestCommonPrefix(String[] strs) {  if(strs == null || strs.</description>
    </item>
    
    <item>
      <title>Integer to Roman</title>
      <link>https://www.tlst.cc/post/leetcode-12-integer-to-roman/</link>
      <pubDate>Wed, 27 Apr 2022 19:59:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-12-integer-to-roman/</guid>
      <description>罗马数字是由七个不同的字母来表示，I, V, X, L, C, D 和 M.
Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
符号 值 I 1 V 5 X 10 L 50 C 100 D 500 M 1000 比如，数值2在罗马数字表示法中写作II，12则写作XII，就是简单的10（X）加上2(II)，27写作XXVII，就是20（XX）加上5（V）加上2（II）。
罗马数字通常从大往小写，但是数值4对应的罗马数字不是IIII，而是IV，V前面的I使用来从数值5中减去1来得到4，同理IX表示9。具体规则是
 I（1）可以被放到V（5）和X（10）之前，用来表示4和9 X（10）可以被放到L（50）和C（100）之前，用来表示40和90 C（100）可以被放到D（500）和M（1000）之前，用来标识400和900  给定一个阿拉伯数字，将其转换为对应的罗马数字
Integer to Roman 示例 示例 1:</description>
    </item>
    
    <item>
      <title>Container With Most Water</title>
      <link>https://www.tlst.cc/post/leetcode-11-container-with-most-water/</link>
      <pubDate>Tue, 26 Apr 2022 21:05:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-11-container-with-most-water/</guid>
      <description>给定一个数组里面包含n个数字，这n个数字分别表示n个柱子的高度。
我们选定任意两根柱子，配合x轴，我们都能够组合成一个容器，找到所有柱子中任意两个组合所能组成的容器中，能够装水最多的那个，返回最大的容积。
注意，你不能倾斜容器。
Container With Most Water 示例 示例 1:
输入: height = [1,8,6,2,5,4,8,3,7] 输出: 49 解释: 这一组数字表示的柱子中，能够组成的最大容器是第二根柱子和最后一根柱子，整个容器的宽度是7，高度是7，最大容积是49 Example 2:
输入: height = [1,1] 输出: 1 限制条件:
 n == height.length 2 &amp;lt;= n &amp;lt;= 105 0 &amp;lt;= height[i] &amp;lt;= 104  解决方案 解决方案 1 - 暴力破解 对于每一根柱子，我们可以遍历右边的所有柱子，然后计算出所有可能的组合对应的所有容积，然后就可以找到容积最大的那一个。示例代码如下。
class Solution {  public int _maxArea(int[] height) { //超出时间限制  int maxArea = 0;  for(int index = 0;index &amp;lt; height.</description>
    </item>
    
    <item>
      <title>Regular Expression Matching</title>
      <link>https://www.tlst.cc/post/leetcode-10-regular-expression-matching/</link>
      <pubDate>Sun, 24 Apr 2022 21:05:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-10-regular-expression-matching/</guid>
      <description>初次看到这个题目时，给定测试用例，脑子倒是能够很快计算出是否匹配，但是具体怎么通过代码来进行实现却是一时间没太想清楚。后面看了很多的解决方案，大多数解决方案思路的话基本都是动态规划，此外也了解到一个FAM，有限自动机的概念，这个概念在实现正则表达式时好像还蛮有用的。
给定一个字符串S和一个模式P，实现一个正则匹配，此处我们仅需要支持.和*。其中，.匹配任意字符，*匹配零次或者多次前面的元素。注意此处是匹配，不是查找，也就是我们的模式必须恰好匹配整个字符串。
Regular Expression Matching 示例 1:
输入: s = &amp;#34;aa&amp;#34;, p = &amp;#34;a&amp;#34; 输出: false 解释: 模式只能匹配字符串中的一个字符 示例 2:
输入: s = &amp;#34;aa&amp;#34;, p = &amp;#34;a*&amp;#34; 输出: true 解释: *表示匹配前面这个元素一次或者多次，所以我们可以匹配a两次 示例 3:
输入: s = &amp;#34;ab&amp;#34;, p = &amp;#34;.*&amp;#34; 输出: true 解释: &amp;#34;.*&amp;#34;意味着我们可以匹配任意字符多次 限制条件:
 1 &amp;lt;= s.length &amp;lt;= 20 1 &amp;lt;= p.</description>
    </item>
    
    <item>
      <title>Reverse Integer</title>
      <link>https://www.tlst.cc/post/leetcode-7-reverse-integer/</link>
      <pubDate>Sat, 23 Apr 2022 18:57:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-7-reverse-integer/</guid>
      <description>给定一个32位的整数，以十进制表示，返回将其所有数字位翻转之后得到的新的数值，如果由于翻转导致数字溢出，那么返回0。此处假定我们使用的系统不支持64位的整数。
Reverse Integer 示例 示例 1:
输入: x = 123 输出: 321 示例 2:
输入: x = -123 输出: -321 示例 3:
输入: x = 120 输出: 21 限制条件:
 -2 ^ 31 &amp;lt;= x &amp;lt;= 2 ^ 31 - 1  解决方案 解决方案 1 让我们再次回顾题目，整个翻转过程其实并不复杂，但是唯一需要注意的就是，我们可能发生溢出。
比如假定我们使用的不是32位整数，而是八位整数，其范围在[-128 ~ 127]之间。那么当我们尝试对这个范围内的一些整数进行翻转时可能会溢出，比如127，翻转之后是721，显然它已经远远超过了8位整数所能表示的范围。
那么我们如何检测是否发生了溢出呢？让我们看一下整个翻转流程</description>
    </item>
    
    <item>
      <title>Zigzag Conversion</title>
      <link>https://www.tlst.cc/post/leetcode-6-zigzag-conversion/</link>
      <pubDate>Sat, 23 Apr 2022 18:44:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-6-zigzag-conversion/</guid>
      <description>我们来定义一个zigzag模式，给定一个字符串，比如PAYPALISHIRING，特定条件下，它的zigzag模式为PAHNAPLSIIGYIR，这是我们将原字符串按照一定的规则打破重组之后得到的。
具体规则是，首先将这个字符串中的各个字符按照英文字母N的书写顺序在特定的行数限制下进行排列，然后我们收集每一行的字符，并按照行从上往下将各行中收集到的字符串拼接成一个新的字符串。
比如，对于字符串PAYPALISHIRING，首先按照字母N的书写顺序在三行上进行重新排列，将得到
P A H N A P L S I I G Y I R 然后我们将每一行上的字符收集起来，得到
PAHN APLSIIG YIR 并按照从上往下的顺序将多行收集到的字符串拼接成一个新的字符串PAHN + APLSIIG + YIR =&amp;gt; PAHNAPLSIIGYIR。
同理，如果行数为4，那么重新排列之后是
P I N A L S I G Y A H R P I 重新收集拼接之后将会是PIN + ALSIG + YAHR + PI + =&amp;gt;PINALSIGYAHRPI。</description>
    </item>
    
    <item>
      <title>Longest Palindromic Substring</title>
      <link>https://www.tlst.cc/post/leetcode-5-longest-palindromic-substring/</link>
      <pubDate>Thu, 21 Apr 2022 12:01:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-5-longest-palindromic-substring/</guid>
      <description>给定一个字符串，返回其最长回文字串。
The Longest Palindromic Substring 示例 示例 1:
输入: s = &amp;#34;babad&amp;#34; 输出: &amp;#34;bab&amp;#34; 解释: &amp;#34;aba&amp;#34;也是一个正确的答案 示例 2:
输入: s = &amp;#34;cbbd&amp;#34; 输出: &amp;#34;bb&amp;#34; 限制条件:
 1 &amp;lt;= s.length &amp;lt;= 1000 字符串中仅仅包含数组和字母  解决方案 对于这道题目，leetcode自己给出了五个解决方案，这里我们选择其中两个解决方案来进行分析。
解决方案 1 - 动态规划 我们前面刚好写了一篇关于动态规划的文章，感兴趣的同学可以先看看这篇文章 - 动态规划的系统性方法。接下来我们就按照这篇文章里面的阐述的方法来对这个问题进行分析。
让我们回顾下动态规划的系统性方法
* 首先，问你自己一个问题，我真的需要使用动态规划解决这个问题吗或者说我真的可以用动态规划解决这个问题吗  * 定义我们的状态 * 定义我们的递归关系，或者说是状态迁移方程 * 列出所有状态转换及其各自状态迁移的条件 * 定义我们的基本情况 * 实现一个朴素的递归解决方案 * 使用自顶向下的方法（Memoization）对我们递归的解决方案进行优化 * 使用自底向上的方法（Tabulation）消除递归的开销 可以用动态规划解决这个问题吗 这个问题同样是让我们基于一个特定的条件求解一个最大的结果，条件是回文序列，结果是最大字串长度。我们可以看出这是一个最优解问题，那么它是否包含一个优化结构呢？</description>
    </item>
    
    <item>
      <title>Median of Two Sorted Arrays</title>
      <link>https://www.tlst.cc/post/leetcode-4-medianof-two-sorted-arrays/</link>
      <pubDate>Wed, 20 Apr 2022 13:10:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-4-medianof-two-sorted-arrays/</guid>
      <description>给定两个有序的数组nums1和nums2，其对应的元素个数分别为m和n，返回这两个数组的中值。
解决方案总体的时间复杂度不能超过O(log (m+n))。
Median of Two Sorted Arrays 示例 示例 1:
输入: nums1 = [1,3], nums2 = [2] 输出: 2.00000 解释: 合并后的数组是[1,2,3]，中值是2. 示例 2:
输入: nums1 = [1,2], nums2 = [3,4] 输出: 2.50000 解释: 合并后的数组是[1,2,3,4]，中值是(2 + 3) / 2 = 2.5. 限制条件:
 nums1.length == m nums2.length == n 0 &amp;lt;= m &amp;lt;= 1000 0 &amp;lt;= n &amp;lt;= 1000 1 &amp;lt;= m + n &amp;lt;= 2000 -106 &amp;lt;= nums1[i], nums2[i] &amp;lt;= 106  解决方案 解决方案 1 - 合并数组 如果我们抛开时间复杂度的限制，我们将两个数组进行合并，然后再计算中值就比较简单了。但是整体的空间复杂度是O(m + n)，时间复杂度是O(m + n)。</description>
    </item>
    
    <item>
      <title>Longest Substring Without Repeating Characters</title>
      <link>https://www.tlst.cc/post/leetcode-3-longest-substring-without-repeating-characters/</link>
      <pubDate>Wed, 20 Apr 2022 09:13:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-3-longest-substring-without-repeating-characters/</guid>
      <description>给定一个字符串，找到它里面不包含重复字符的最长的字串。
Longest Substring Without Repeating Characters 示例 示例 1:
输入: s = &amp;#34;abcabcbb&amp;#34; 输出: 3 解释: 满足条件的最长字串是&amp;#34;abc&amp;#34;，字符串长度是3 示例 2:
输入: s = &amp;#34;bbbbb&amp;#34; 输出: 1 解释: 满足条件的最长字串是&amp;#34;b&amp;#34;，长度是1 示例 3:
输入: s = &amp;#34;pwwkew&amp;#34; 输出: 3 解释: 满足条件的最长字串是&amp;#34;wke&amp;#34;，长度是3 Constraints:
 0 &amp;lt;= s.length &amp;lt;= 5 * 10000 字符串可能包含英文字母，数字，特殊符号以及空格  解决方案 解决方案 1 - BitSet class Solution {  public int lengthOfLongestSubstring(String s) {  java.</description>
    </item>
    
    <item>
      <title>Add Two Number</title>
      <link>https://www.tlst.cc/post/leetcode-2-add-two-number/</link>
      <pubDate>Tue, 19 Apr 2022 17:44:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-2-add-two-number/</guid>
      <description>给定两个非空的链表，分别代表两个非负整数，链表的每一个节点代表整数的一位数字，数字是按照倒序存储的。请对这两个数字进行求和，并将结果按照同样的格式进行返回。
此处我们假定，这两个数字不包含任何前置0，当然了除了数字0本身。
Add Two Number 示例 示例 1:
输入: l1 = [2,4,3], l2 = [5,6,4] 输出: [7,0,8] 解释: 342 + 465 = 807. 示例 2:
输入: l1 = [0], l2 = [0] 输出: [0] 示例 3:
输入: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] 输出: [8,9,9,9,0,0,0,1] Constraints:
 每一个数字的位数也即每个链表的长度限制在范围[1, 100]. 0 &amp;lt;= Node.</description>
    </item>
    
    <item>
      <title>LeetCode</title>
      <link>https://www.tlst.cc/post/leetcode/</link>
      <pubDate>Tue, 19 Apr 2022 12:44:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode/</guid>
      <description>之前得空在leetcode上面刷了一段时间的题目，前前后后一共有三百多道题目吧。先是把简单难度的题目中大家评价还不错的题目都刷了一遍，然后是leetcode前100的题目有些之前没覆盖到的也捡起来刷了一下，这些题目甚至还试了一下多种可能的解决方案。
前期刷题的时候，其实只是自己实现了一下，整个的解决方案比较繁琐，没有花时间在评论区多看一看。
其实当我仔细看了有些大佬的解决方案之后，有时候甚至会产生一些羞愧感，明明相似的题目我之前做过，为什么现在又不会了等等。
在刷前一百的题目的时候，我有仔细对比自己的解决方案和其他人提供的解决方案有什么不同，事实证明，在评论区泡一泡还是有不少收获的。所以现在又回过头来看下之前刷的题目，然后慢慢整理一遍。
列表  1 - Two Sum 2 - Add Two Number 3 - Longest Substring Without Repeating Characters 4 - Median of Two Sorted Arrays 5 - Longest Palindromic Substring 6 - Zigzag Conversion 7 - Reverse Integer 10 - Regular Expression Matching 11 - Container With Most Water 12 - Integer to Roman 14 - Longest Common Prefix 15 - 3Sum 16 - 3Sum Closest 17 - Letter Combinations of a Phone Number 19 - Remove Nth Node From End of List 20 - Valid Parentheses 22 - Generate Parentheses 23 - Merge k Sorted Lists  </description>
    </item>
    
    <item>
      <title>Two Sum</title>
      <link>https://www.tlst.cc/post/leetcode-1-two-sum/</link>
      <pubDate>Tue, 19 Apr 2022 12:44:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-1-two-sum/</guid>
      <description>Two Sum 概述 给定一个整数数组和一个目标值，在数组中找到两个数字，满足这两个数字之和等于目标值，返回这两个数字的索引。
此处我们假定这个数组中只有一个组合满足上述条件，此外，你不能使用同一个数字两次。
你可以以任意顺序返回组合的索引。
示例 1:
输入: nums = [2,7,11,15], target = 9 输出: [0,1] 解释: Because nums[0] + nums[1] == 9, we return [0, 1]. 示例 2:
输入: nums = [3,2,4], target = 6 输出: [1,2] 示例 3:
输入: nums = [3,3], target = 6 输出: [0,1] 限制条件:</description>
    </item>
    
  </channel>
</rss>
