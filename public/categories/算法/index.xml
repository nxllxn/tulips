<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>算法 on Tulips</title>
    <link>https://www.tlst.cc/categories/%E7%AE%97%E6%B3%95/</link>
    <description>Recent content in 算法 on Tulips</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <copyright>Copyright @ 2022 郁金香啊</copyright>
    <lastBuildDate>Sun, 24 Apr 2022 21:05:33 +0800</lastBuildDate><atom:link href="https://www.tlst.cc/categories/%E7%AE%97%E6%B3%95/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Regular Expression Matching</title>
      <link>https://www.tlst.cc/post/leetcode-10-regular-expression-matching/</link>
      <pubDate>Sun, 24 Apr 2022 21:05:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-10-regular-expression-matching/</guid>
      <description>初次看到这个题目时，给定测试用例，脑子倒是能够很快计算出是否匹配，但是具体怎么通过代码来进行实现却是一时间没太想清楚。后面看了很多的解决方案，大多数解决方案思路的话基本都是动态规划，此外也了解到一个FAM，有限自动机的概念，这个概念在实现正则表达式时好像还蛮有用的。
给定一个字符串S和一个模式P，实现一个正则匹配，此处我们仅需要支持.和*。其中，.匹配任意字符，*匹配零次或者多次前面的元素。注意此处是匹配，不是查找，也就是我们的模式必须恰好匹配整个字符串。
Regular Expression Matching 示例 1:
输入: s = &amp;#34;aa&amp;#34;, p = &amp;#34;a&amp;#34; 输出: false 解释: 模式只能匹配字符串中的一个字符 示例 2:
输入: s = &amp;#34;aa&amp;#34;, p = &amp;#34;a*&amp;#34; 输出: true 解释: *表示匹配前面这个元素一次或者多次，所以我们可以匹配a两次 示例 3:
输入: s = &amp;#34;ab&amp;#34;, p = &amp;#34;.*&amp;#34; 输出: true 解释: &amp;#34;.*&amp;#34;意味着我们可以匹配任意字符多次 限制条件:
 1 &amp;lt;= s.length &amp;lt;= 20 1 &amp;lt;= p.</description>
    </item>
    
    <item>
      <title>Reverse Integer</title>
      <link>https://www.tlst.cc/post/leetcode-7-reverse-integer/</link>
      <pubDate>Sat, 23 Apr 2022 18:57:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-7-reverse-integer/</guid>
      <description>给定一个32位的整数，以十进制表示，返回将其所有数字位翻转之后得到的新的数值，如果由于翻转导致数字溢出，那么返回0。此处假定我们使用的系统不支持64位的整数。
Reverse Integer 示例 示例 1:
输入: x = 123 输出: 321 示例 2:
输入: x = -123 输出: -321 示例 3:
输入: x = 120 输出: 21 限制条件:
 -2 ^ 31 &amp;lt;= x &amp;lt;= 2 ^ 31 - 1  解决方案 解决方案 1 让我们再次回顾题目，整个翻转过程其实并不复杂，但是唯一需要注意的就是，我们可能发生溢出。
比如假定我们使用的不是32位整数，而是八位整数，其范围在[-128 ~ 127]之间。那么当我们尝试对这个范围内的一些整数进行翻转时可能会溢出，比如127，翻转之后是721，显然它已经远远超过了8位整数所能表示的范围。
那么我们如何检测是否发生了溢出呢？让我们看一下整个翻转流程</description>
    </item>
    
    <item>
      <title>Zigzag Conversion</title>
      <link>https://www.tlst.cc/post/leetcode-6-zigzag-conversion/</link>
      <pubDate>Sat, 23 Apr 2022 18:44:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-6-zigzag-conversion/</guid>
      <description>我们来定义一个zigzag模式，给定一个字符串，比如PAYPALISHIRING，特定条件下，它的zigzag模式为PAHNAPLSIIGYIR，这是我们将原字符串按照一定的规则打破重组之后得到的。
具体规则是，首先将这个字符串中的各个字符按照英文字母N的书写顺序在特定的行数限制下进行排列，然后我们收集每一行的字符，并按照行从上往下将各行中收集到的字符串拼接成一个新的字符串。
比如，对于字符串PAYPALISHIRING，首先按照字母N的书写顺序在三行上进行重新排列，将得到
P A H N A P L S I I G Y I R 然后我们将每一行上的字符收集起来，得到
PAHN APLSIIG YIR 并按照从上往下的顺序将多行收集到的字符串拼接成一个新的字符串PAHN + APLSIIG + YIR =&amp;gt; PAHNAPLSIIGYIR。
同理，如果行数为4，那么重新排列之后是
P I N A L S I G Y A H R P I 重新收集拼接之后将会是PIN + ALSIG + YAHR + PI + =&amp;gt;PINALSIGYAHRPI。</description>
    </item>
    
    <item>
      <title>Longest Palindromic Substring</title>
      <link>https://www.tlst.cc/post/leetcode-5-longest-palindromic-substring/</link>
      <pubDate>Thu, 21 Apr 2022 12:01:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-5-longest-palindromic-substring/</guid>
      <description>给定一个字符串，返回其最长回文字串。
The Longest Palindromic Substring 示例 示例 1:
输入: s = &amp;#34;babad&amp;#34; 输出: &amp;#34;bab&amp;#34; 解释: &amp;#34;aba&amp;#34;也是一个正确的答案 示例 2:
输入: s = &amp;#34;cbbd&amp;#34; 输出: &amp;#34;bb&amp;#34; 限制条件:
 1 &amp;lt;= s.length &amp;lt;= 1000 字符串中仅仅包含数组和字母  解决方案 对于这道题目，leetcode自己给出了五个解决方案，这里我们选择其中两个解决方案来进行分析。
解决方案 1 - 动态规划 我们前面刚好写了一篇关于动态规划的文章，感兴趣的同学可以先看看这篇文章 - 动态规划的系统性方法。接下来我们就按照这篇文章里面的阐述的方法来对这个问题进行分析。
让我们回顾下动态规划的系统性方法
* 首先，问你自己一个问题，我真的需要使用动态规划解决这个问题吗或者说我真的可以用动态规划解决这个问题吗  * 定义我们的状态 * 定义我们的递归关系，或者说是状态迁移方程 * 列出所有状态转换及其各自状态迁移的条件 * 定义我们的基本情况 * 实现一个朴素的递归解决方案 * 使用自顶向下的方法（Memoization）对我们递归的解决方案进行优化 * 使用自底向上的方法（Tabulation）消除递归的开销 可以用动态规划解决这个问题吗 这个问题同样是让我们基于一个特定的条件求解一个最大的结果，条件是回文序列，结果是最大字串长度。我们可以看出这是一个最优解问题，那么它是否包含一个优化结构呢？</description>
    </item>
    
    <item>
      <title>Median of Two Sorted Arrays</title>
      <link>https://www.tlst.cc/post/leetcode-4-medianof-two-sorted-arrays/</link>
      <pubDate>Wed, 20 Apr 2022 13:10:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-4-medianof-two-sorted-arrays/</guid>
      <description>给定两个有序的数组nums1和nums2，其对应的元素个数分别为m和n，返回这两个数组的中值。
解决方案总体的时间复杂度不能超过O(log (m+n))。
Median of Two Sorted Arrays 示例 示例 1:
输入: nums1 = [1,3], nums2 = [2] 输出: 2.00000 解释: 合并后的数组是[1,2,3]，中值是2. 示例 2:
输入: nums1 = [1,2], nums2 = [3,4] 输出: 2.50000 解释: 合并后的数组是[1,2,3,4]，中值是(2 + 3) / 2 = 2.5. 限制条件:
 nums1.length == m nums2.length == n 0 &amp;lt;= m &amp;lt;= 1000 0 &amp;lt;= n &amp;lt;= 1000 1 &amp;lt;= m + n &amp;lt;= 2000 -106 &amp;lt;= nums1[i], nums2[i] &amp;lt;= 106  解决方案 解决方案 1 - 合并数组 如果我们抛开时间复杂度的限制，我们将两个数组进行合并，然后再计算中值就比较简单了。但是整体的空间复杂度是O(m + n)，时间复杂度是O(m + n)。</description>
    </item>
    
    <item>
      <title>Longest Substring Without Repeating Characters</title>
      <link>https://www.tlst.cc/post/leetcode-3-longest-substring-without-repeating-characters/</link>
      <pubDate>Wed, 20 Apr 2022 09:13:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-3-longest-substring-without-repeating-characters/</guid>
      <description>给定一个字符串，找到它里面不包含重复字符的最长的字串。
Longest Substring Without Repeating Characters 示例 示例 1:
输入: s = &amp;#34;abcabcbb&amp;#34; 输出: 3 解释: 满足条件的最长字串是&amp;#34;abc&amp;#34;，字符串长度是3 示例 2:
输入: s = &amp;#34;bbbbb&amp;#34; 输出: 1 解释: 满足条件的最长字串是&amp;#34;b&amp;#34;，长度是1 示例 3:
输入: s = &amp;#34;pwwkew&amp;#34; 输出: 3 解释: 满足条件的最长字串是&amp;#34;wke&amp;#34;，长度是3 Constraints:
 0 &amp;lt;= s.length &amp;lt;= 5 * 10000 字符串可能包含英文字母，数字，特殊符号以及空格  解决方案 解决方案 1 - BitSet class Solution {  public int lengthOfLongestSubstring(String s) {  java.</description>
    </item>
    
    <item>
      <title>Add Two Number</title>
      <link>https://www.tlst.cc/post/leetcode-2-add-two-number/</link>
      <pubDate>Tue, 19 Apr 2022 17:44:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-2-add-two-number/</guid>
      <description>给定两个非空的链表，分别代表两个非负整数，链表的每一个节点代表整数的一位数字，数字是按照倒序存储的。请对这两个数字进行求和，并将结果按照同样的格式进行返回。
此处我们假定，这两个数字不包含任何前置0，当然了除了数字0本身。
Add Two Number 示例 示例 1:
输入: l1 = [2,4,3], l2 = [5,6,4] 输出: [7,0,8] 解释: 342 + 465 = 807. 示例 2:
输入: l1 = [0], l2 = [0] 输出: [0] 示例 3:
输入: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] 输出: [8,9,9,9,0,0,0,1] Constraints:
 每一个数字的位数也即每个链表的长度限制在范围[1, 100]. 0 &amp;lt;= Node.</description>
    </item>
    
    <item>
      <title>LeetCode</title>
      <link>https://www.tlst.cc/post/leetcode/</link>
      <pubDate>Tue, 19 Apr 2022 12:44:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode/</guid>
      <description>之前得空在leetcode上面刷了一段时间的题目，前前后后一共有三百多道题目吧。先是把简单难度的题目中大家评价还不错的题目都刷了一遍，然后是leetcode前100的题目有些之前没覆盖到的也捡起来刷了一下，这些题目甚至还试了一下多种可能的解决方案。
前期刷题的时候，其实只是自己实现了一下，整个的解决方案比较繁琐，没有花时间在评论区多看一看。
其实当我仔细看了有些大佬的解决方案之后，有时候甚至会产生一些羞愧感，明明相似的题目我之前做过，为什么现在又不会了等等。
在刷前一百的题目的时候，我有仔细对比自己的解决方案和其他人提供的解决方案有什么不同，事实证明，在评论区泡一泡还是有不少收获的。所以现在又回过头来看下之前刷的题目，然后慢慢整理一遍。
列表  1 - Two Sum 2 - Add Two Number 3 - Longest Substring Without Repeating Characters 4 - Median of Two Sorted Arrays 5 - Longest Palindromic Substring 6 - Zigzag Conversion 7 - Reverse Integer 10 - Regular Expression Matching  </description>
    </item>
    
    <item>
      <title>Two Sum</title>
      <link>https://www.tlst.cc/post/leetcode-1-two-sum/</link>
      <pubDate>Tue, 19 Apr 2022 12:44:33 +0800</pubDate>
      
      <guid>https://www.tlst.cc/post/leetcode-1-two-sum/</guid>
      <description>Two Sum 概述 给定一个整数数组和一个目标值，在数组中找到两个数字，满足这两个数字之和等于目标值，返回这两个数字的索引。
此处我们假定这个数组中只有一个组合满足上述条件，此外，你不能使用同一个数字两次。
你可以以任意顺序返回组合的索引。
示例 1:
输入: nums = [2,7,11,15], target = 9 输出: [0,1] 解释: Because nums[0] + nums[1] == 9, we return [0, 1]. 示例 2:
输入: nums = [3,2,4], target = 6 输出: [1,2] 示例 3:
输入: nums = [3,3], target = 6 输出: [0,1] 限制条件:</description>
    </item>
    
  </channel>
</rss>
