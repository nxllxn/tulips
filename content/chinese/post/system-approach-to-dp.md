---
title: "动态规划的系统性方法"
date: 2022-03-24T20:29:33+08:00
# post thumb
images:
- "images/dp/dp.jpg"
#author
author: "郁金香啊"
# description
description: "动态规划的系统性方法"
# Taxonomies
categories: ["Tutorials","Algorithms"]
tags: ["算法","Algorithm","DP","动态规划","Dynamic Programming"]
type: "regular"
draft: false
---

其实很早就想要写一篇动态规划相关的文章，把这个非常棒的算法或者说是一种问题思考方式推荐给更多的人，不 论你是程序员还是其他任何职业的从业人员， 了解动态
规划都会对你或者说你看待一个问题的方式或多或少产生一些影响，因为它真的太强大了。 那么为什么我会这么觉得呢?

第一，动态规划几乎可以说是分治在现实世界里面最优雅的一种表达方式。 当我们面对一个非常复杂的问题时，如果这个问题能够划分为子问题并逐个击破，那么此时不用
想太多，动态规划大概率是解决这个问题的一个最好的工具了，不论是指导你对这个问题进行快速的分析还是最终作为实际的解决方案，动态规划绝对会让你的眼前一亮。

第二，动态规划不会止步于问题分析以及给出一个递归的解决方案。的确，当我们使用动态规划时，当我们明确了我们的状态以及状态迁移方程，我们很容易得到一个
基于递归的解决方案。这是动态规划的一大优点所在，即你不需要将一整个问题放到你的脑海中完完整整的想清楚，你只需要瞥见其中的规律，便可以快刀斩乱麻，轻松地
解决一个非常复杂的问题；但是递归虽好，如果有时候使用不当，你的程序可能需要大量的资源，执行大量的计算，花费更多的时间才能得到最终的结果；好在动态规划
并没有止步于仅仅给出一个递归的解决方案，除此之外，我们只要使用一些其他的方法或者依赖一些恰当的数据结构，就能够得到一个高效到令人拍案叫绝的解决方案。

初次接触到动态规划时，我甚至都不知道自己接触了这个概念，其实就是大家可能经常接触到的一个数学问题，斐波那契数列。

> 斐波那契数列（Fibonacci sequence），又称黄金分割数列，因数学家莱昂纳多·斐波那契（Leonardo Fibonacci）以兔子繁殖为例子而引入，故又称为“兔子
> 数列”，指的是这样一个数列：1、1、2、3、5、8、13、21、34、……在数学上，斐波那契数列以如下被以递推的方法定义：F(0)=0，F(1)=1, F(n)=F(n - 1)+
> F(n - 2)（n ≥ 2，n ∈ N*;

你可能会问道，这个斐波那契数列和动态规划又有什么关系呢，哈哈，的确，乍一看，可能这两者之间并没有太大联系，不过这并不奇怪，主要是因为我们已经跳过了动态
规划的部分，转向了当我们使用动态规划给这个问题求解时所得到的最终的解决方案，所以我们已经看不到动态规划的影子了，也就无从探究它的魅力了。

那么怎么办呢，我们可能从这个问题的源头开始说起，我这里不会举这个百度百科或者维基百科上出现的兔子问题，我所要想你展示的是另一个非常有趣的问题--爬楼梯。

> 爬楼梯问题，假设有十级楼梯，你每次移动时，要么移动一级台阶，要么移动两级台阶，请问从楼梯的底部到顶部你一共有多少种可能的方式？

当我们拿到这个问题时，我们的大脑可能会不由自主的开始枚举所有可能的结果，比如每一步都只向上移动一级台阶是一种可能的走法，每一步都向上移动两级台阶是一种
走法，前面四步每一步都移动两级台阶，然后第五步第六步分别移动以及台阶又是一种走法。如此循环往复尝试罗列所有的可能的结果，但是你很快就会发现，想要罗列出
所有结果对你来说太难了，此外你也应该已经注意到了，现在还仅仅是十几台阶，如果是二十级三十级甚至更多，使用这种枚举的方式几乎是不可能行得通的。

此时，动态规划的思想就很容易应用到这个问题上了。来，让我们转换一下思路，加入你现在只剩最后一次移动就到达第十级阶梯了，那么你可能的情况是什么呢，你会发
现此时只会有两种结果，那就是你要么在第九级阶梯，此时你向上移动一级阶梯就可以到达终点了；要么你在第八级阶梯，此时你向上移动两级阶梯同样可以到达终点。那
么换句话说，你想要到达终点，就必须先到达第八级阶梯或者第九级阶梯，也意味着，走到终点的可能的走法等价于走到第八级阶梯的走法加上走到第九级阶梯的走法。同
理，想要到达第九级阶梯的走法又等价于走到第七级阶梯的走法加上走到第八级阶梯的走法。一次类推，我们可以得到一个方程式`f(n) = f(n - 1) + f(n - 2)`。
此时我们暂时不考虑所谓边界条件。

OK我们此时已经拿到了一个所谓的方程`f(n) = f(n - 1) + f(n - 2)`，此时你可能又会尝试调转你的脑细胞还是进行计算了。`f(10) = f(9) + f(8)、
f(9) = f(8) + f(7) => f(10) = f(8) + f(7) + f(8)...`。你尝试对最终的结果进行展开，但是你慢慢就会发现你的脑细胞不够用了。其实此处你在做的
事情就是`递归求解`，只是这个求解过程可能交给计算机要更加合适，留着你的脑细胞日后想其他问题吧哈哈。不过此处你就会发现递归求解过程可能出现的问题
* 当我们进行一次展开之后我们就会发现表达式`f(10) = f(8) + f(7) + f(8)`中出现了两个`f(8)`,其实这个我们也称之为子问题，我们发现这个子问题可能被
  重复计算了
* 即使我们想办法解决了重复子问题的这个缺点（动态规划很擅长这个，同时也是动态规划问题中一个很核心的步骤），我们仍然需要大量的方法调用，这是递归的很明显
  的一个缺点，当我们的计算量比较大时，大量的方法调用，还是会对计算性能产生很大的影响。所以我上面也提到过，动态规划并不会止步于一个递归的解决方案，除此
  之外，它还会更进一步，再进一步，最终得到一个迭代的解决方案，让我们的程序更加快速高效地计算出我们想要的结果。
  
那么让我们回到这个问题本身，我们如何利用迭代的方式得到我们最终的结果呢？让我们想一下，如果只有一级阶梯，那么显然我们只有一种走法，因此我们可以得到
`f(1) = 1`；如果有两级阶梯，我们要么分两步走，每步向上移动一级台阶，也可以一次性向上移动两级台阶，所以我们有两种可能的走法，所以可以得到`f(2) = 3`

好的，很棒到目前位置一切都很棒，也很好理解。但是如果是三级台阶呢，哈哈，脑子是不是又转不过来了。不要怕，我们已经有了一个现成的方程式可以用了对吧，就是
前面提到的`f(n) = f(n - 1) + f(n - 2)`，那么`f(3)`就应该等于`f(2) + f(1)`结果为`3`，同理让我们继续求解
```markdown
* `f(1) = 1`
* `f(2) = 2`
* `f(3) = f(2) + f(1) = 3`
* `f(4) = f(3) + f(2) = 5`
* `f(5) = f(4) + f(3) = 8`
* `f(6) = f(5) + f(4) = 13`
* `f(7) = f(6) + f(5) = 21`
* `f(8) = f(7) + f(6) = 34`
* `f(9) = f(8) + f(7) = 55`
* `f(10) = f(9) + f(8) = 89`
* ...
```
完美，我们得到了最终的答案，同时你也会发现，这个等号左边的数列似乎有些眼熟，哈哈，是不是没有想到斐波那契数列居然和爬楼梯有点关系，那么如果你腿比较长，
偶尔可以跨三级或者四级阶梯，你知道怎么计算了吗哈哈。

好的第一部分就到此结束了，只是简单感受一下动态规划，接下来我会讲一下动态规划的系统性方法，其实这是翻译自博客[A Systematic Approach to Dynamic 
Programming](https://betterprogramming.pub/a-systematic-approach-to-dynamic-programming-54902b6b0071)，感兴趣的小伙伴也可以直
接看原博客，这是我接触动态规划以来看到的最好最好的一篇博客了，后面也会将它翻译过来。

# 动态规划的系统性方法
待翻译。。。