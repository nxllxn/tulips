---
title: "Median of Two Sorted Arrays"
date: 2022-04-20T13:10:33+08:00
# post thumb
images:
- "images/leetcode/4-median-of-two-sorted-arrays.png"
#author
author: "郁金香啊"
# description
description: "Median of Two Sorted Arrays"
# Taxonomies
categories: ["LeetCode","算法"]
tags: ["Java","LeetCode","算法","困难难度"]
type: "regular"
draft: false
---

给定两个有序的数组nums1和nums2，其对应的元素个数分别为m和n，返回这两个数组的中值。

解决方案总体的时间复杂度不能超过O(log (m+n))。

# Median of Two Sorted Arrays
## 示例
**示例 1:**

```markdown
输入: nums1 = [1,3], nums2 = [2]
输出: 2.00000
解释: 合并后的数组是[1,2,3]，中值是2.
```

**示例 2:**

```markdown
输入: nums1 = [1,2], nums2 = [3,4]
输出: 2.50000
解释: 合并后的数组是[1,2,3,4]，中值是(2 + 3) / 2 = 2.5.
```

**限制条件:**
* `nums1.length == m`
* `nums2.length == n`
* `0 <= m <= 1000`
* `0 <= n <= 1000`
* `1 <= m + n <= 2000`
* `-106 <= nums1[i], nums2[i] <= 106`

## 解决方案
### 解决方案 1 - 合并数组
如果我们抛开时间复杂度的限制，我们将两个数组进行合并，然后再计算中值就比较简单了。但是整体的空间复杂度是O(m + n)，时间复杂度是O(m + n)。

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int[] allNums = new int [nums1.length + nums2.length];
        
        int i = 0;
        int j = 0;
        int index = 0;
        for(;i < nums1.length && j < nums2.length;index ++){
            if(nums1[i] < nums2[j]){
                allNums[index] = nums1[i ++];
            } else {
                allNums[index] = nums2[j ++];
            }
        }
        
        while(i < nums1.length){
            allNums[index ++] = nums1[i ++];
        }
        
        while(j < nums2.length){
            allNums[index ++] = nums2[j ++];
        }
        
        if(allNums.length % 2 == 0){
            return (allNums[allNums.length / 2 - 1] + allNums[allNums.length / 2]) / 2.0;
        } else{
            return allNums[allNums.length / 2];
        }
    }
}
```

### 解决方案 2 - 找到中间的值
由上面的解决方案一我们可以发现，我们做了那么多的合并其实只是为了找到中间的那个值（m + n是奇数）或者那两个值（m + n）是偶数。

所以我们可以做`(m + n)/ 2`次类似归并的操作，就可以找到满足条件的一个或者两个数字了。此时就可以计算出中值了。

使用这种解决方案，空间复杂度变成了O(1)，然后时间复杂度仍然是O((m + n) / 2)还是O(m + n)。其实还是不满足我们题目的要求。这个还是比较好理解的，此处就不贴源码了。

### 解决方案 3 - 切割法
这个方法是评论区提供的一种方法，我也是看了很久才看明白的，但是其讲的还是非常详细的，而且实现了在O(log((m + n)))的时间复杂度的要求下得到了最终的结果，此处将其整个推理过程翻译过来。

我翻译的不好或者大家对原解决方案感兴趣的可以直接看这个[链接](https://leetcode.com/problems/median-of-two-sorted-arrays/discuss/2471/Very-concise-O(log(min(MN)))-iterative-solution-with-detailed-explanation).

**---------------------------------------------------此处是一条分割线----------------------------------------------------**

这个问题是出了名的难以实现，因为它包含了很多的边界场景。很多的实现方案甚至把奇数长度的数组和偶数长度的数组分开来考虑。事实上，在思路上做一个巧妙的转换，这两个场景就可以组合成一个，然后我们就可以得到一个非常简单的解决方案而且几乎不需要做什么特殊处理。

首先让我们看一下**中值**这个概念，我们使用一种稍微不一样的方式来定义我们所谓的中值。

**如果我们把一个排序好的数组等分成两份，那么中值就是左边部分的最大值和右边部分的最小值二者的平均值。**

举个简单的例子，给定排序好的数组是`[2 3 5 7]`，如果我们在数字3和5中间切一刀，看起来像这样`[2 3 / 5 7]`，那么我们可以得到中值就是左边部分的最大值（由于数组是有序的，也就是左边部分的最后一个值）3和右边部分的最小值（由于数组是有序的，也就是右边部分的第一个值）5之和除以2.结果就是4.

{{< notice "note" >}}
注意本文中，我们使用斜杠`/`来表示切割，用`(number / number)`来表示某一个数字刚好被切成了两半。
{{< /notice >}}

让我们再看另一个例子，给定排序好的数组是`[2 3 4 5 6]`，我们会在正好数字4所在的位置切割一刀来把这个数组切成两个等长的部分，看起来像这样`[2 3 (4/4) 5 6]`。

注意此处数字4被切割后的样子`(4/4)`。其实这里就是前面提到的稍微转换一下思路，我们通过把奇数长度的数组最中间的一个数字切割成两部分，或者说复制一份，来实现让数组的总体长度变成偶数，这样两个看似不同的场景就变成同一个了。此时被切开的数字4的两部分被分别分到左右两个数组中，此时我们仍然使用上面的方法得到我们的中值，(4 + 4) / 2 = 4，显然这仍然是我们预期的结果。

为了方便起见，我们使用`L`来表示切割点左边的第一个值，用`R`来表示切割点右边的第一个值。比如在示例`[2 3 5 7]`中，我们可以得到L = 3，R = 5。

让我们来观察一下我们的L和R同数组的总长度N之间有什么样的关系，让我们看一组数据

```markdown
N        Index of L / R
1               0 / 0
2               0 / 1
3               1 / 1  
4               1 / 2      
5               2 / 2
6               2 / 3
7               3 / 3
8               3 / 4
```

我们不难得出一个结论，元素L和R的位置满足`index(L) = (N-1)/2，index(R) = N/2`。所以我们可以推导出`(L + R)/2 = (A[(N-1)/2] + A[N/2])/2`。

为了从一个数组的情况跳跃到两个数组的情况，让我们给数组加上一些虚拟位置，此处我们使用井号`#`来表示这些虚拟位置。当然了，每一个数字也仍然占据一个位置。

```markdown
[6 9 13 18]  ->   [# 6 # 9 # 13 # 18 #]    (N = 4)
position index     0 1 2 3 4 5  6 7  8     (N_Position = 9)

[6 9 11 13 18]->   [# 6 # 9 # 11 # 13 # 18 #]   (N = 5)
position index      0 1 2 3 4 5  6 7  8 9 10    (N_Position = 11)
```

你可以看到，对于一个长度为N的数组，我们总是可以定义出`2*N+1`个位置。我们再回过头来看我们切割点，我们可以发现，我们的中值切割点总是在第N个位置（索引位置从0开始）。由于`index(L) = (N-1)/2，index(R) = N/2`，所以我们可以推导出`index(L) = (CutPosition-1)/2, index(R) = (CutPosition)/2`。

好的，现在让我们看下两个数组的情况

```markdown
A1: [# 1 # 2 # 3 # 4 # 5 #]    (N1 = 5, N1_positions = 11)

A2: [# 1 # 1 # 1 # 1 #]     (N2 = 4, N2_positions = 9)
```
和一个数组的情况相似，我们需要找到两个切割点，分别将两个数组分隔成左右两个部分，并且满足**两个左边部分的数组中的所有数字均小于任意一个右边部分的数组中的任意数字**。如果觉得不好理解，我们可以回到我们的解决方案一，我们如果将两个数组合并成一个数组然后找到中值的话，中值左右的数组仍然是等长的，且左边部分所有数字均小于右边部分的所有数字，由于合并后仍然是有序的，也就是左边部分的最大值（最后一个数字）小于等于右边部分的最小值（第一个数字），此外，左边部分其实就是此处切割后的两个左边部分的数组归并后得到的。

此外，通过观察我们可以得到：
* 我们一共得到了`2N1 + 2N2 + 2`个位置，因此，在切割点的左右两边，我们一定有`N1 + N2`个位置，然后两个切割点占据剩下的两个位置。
* 当我们在第二个数组A2中的切割点位置`C2 = K`时，数组A1上的切割点C1一定满足`C1 = N1 + N2 - K`。
  
比如在上面的A1，A2两个数组中，如果我们的`C2 = 2`，那么我们的`C1 = 4 + 5 - C2 = 7`。两个数组的切割情况看起来将会下面这样

```markdown
[# 1 # 2 # 3 # (4/4) # 5 #]

[# 1 / 1 # 1 # 1 #]  
```
可以看出，我们切割完之后，可以得到两个左边部分，两个右边部分。且对应的L，R满足
```markdown
L1 = A1[(C1-1)/2]; R1 = A1[C1/2];
L2 = A2[(C2-1)/2]; R2 = A2[C2/2];
```

在上面的例子中就是

```markdown
L1 = A1[(7-1)/2] = A1[3] = 4; R1 = A1[7/2] = A1[3] = 4;
L2 = A2[(2-1)/2] = A2[0] = 1; R2 = A1[2/2] = A1[1] = 1;
```
那么现在我们如何判定这一次切割是我们想要的呢，因为L1，L2分别是两个左边部分的最大值，R1，R2分别是两个右边部分的最小值，我们需要满足`L1 <= R1 && L1 <= R2 && L2 <= R1 && L2 <= R2`。

之所以这样是因为像前面提到的，我们需要保证归并后左边部分的所有值均小于归并后右边部分所有的值。由于两个数组本来就是有序的，我们天然就满足`L1 <= R1 and L2 <= R2`，那么我们仅仅需要保证`L1 <= R2 and L2 <= R1`。

好的，现在我们就可以使用二分法来找到我们想要的切割点和我们最终的中值了。关键部分的伪代码看起来是这样的
```markdown
* 如果L1 > R2，说明我们此次切割之后，A1的左边部分包含了太多的大数字（也等价于A2的右边部分包含了太少的小数字），所以我们需要将切割点C1向左移（等价于将切割点C2向右移）。
* 如果L2 > R1，说明我们此次切割之后，A2的左边部分包含了太多的大数字（也等价于A1的右边部分包含了太少的小数字），所以我们需要将切割点C2向左移（等价于将切割点C1向右移）。
* 如果不是上述两种情况，我们其实就找到了合适的切割点，也就找到了我们最终的中值`(max(L1, L2) + min(R1, R2)) / 2`。
```

两个额外的提示

**首先**，因为一旦我们确定了C1，C2中的任意一个，我们可以很轻易地推导出另一个，我们可以移动其中一个切割点，然后使用公式计算出另一个。然而，我们移动更短的数组上的切割点能够有更好的效果，原因是，在短数组上，所有的可以切割的位置更有可能是我们最终想要的切割点，但是对于长数组，两端的位置可能远远远离实际的切割点，我们可能需要移动更多次才能得到最终结果。

比如，给定两个数组`[1], [2 3 4 5 6 7 8]`，显然，数字2和3之间的切割点是不可能是最终的结果的。因为较短的数组中没有足够的元素或者说足够大的元素来平衡第二个数组分割后的右边的部分`[3 4 5 6 7 8]`。

而且当我们使用长数组中的位置来做切割点时，我们推导出的较短数组的切割点位置可能远远在数组元素的索引之外，我们不得不做更多的边界检查。但是当我们先用较短数组来进行切割时，我们不需要进行任何检查，我们甚至能够得到一个O(log(min(N1, N2)))的时间复杂度。

**其次**，我们唯一的边界场景是，当我们最终的切割点位于最开始的位置（0th）或者最后的位置（2Nth）。比如，如果`C2 = 2N2`, 那么`R2 = A2[2*N2/2] = A2[N2]`，此时我们发现我们数组索引越界了。

为了解决这个问题，我们可以再假定数组A1和A2都有两个虚拟元素`A[-1]`以及`A[N]`，而且满足，`A[-1] = Integer.MIN_VALUE`以及`A[N] = Integer.MAX_VALUE`。这个假设并不会影响实际的执行结果，但是可以让我们的代码实现变得更加简单。

这两个额外的提示可能不像前面的流程那么容易理解，但是最终的代码实现看起来将会是下面这样
```java
public class Solution {
    double findMedianSortedArrays(int[] nums1, int nums2) {
        int N1 = nums1.length;
        int N2 = nums2.length;
        if (N1 < N2) return findMedianSortedArrays(nums2, nums1);	// 此处交换两个数组，总是让A2是较短的那个数组，之后我们总是先对A2进行切割。

        int lo = 0, hi = N2 * 2;
        while (lo <= hi) {
            int mid2 = (lo + hi) / 2;   // 切割A2
            int mid1 = N1 + N2 - mid2;  // 计算A1相应的切割点

            double L1 = (mid1 == 0) ? Integer.MIN_VALUE : nums1[(mid1-1)/2];	// 分别计算出L1, R1, L2, R2
            double L2 = (mid2 == 0) ? Integer.MIN_VALUE : nums2[(mid2-1)/2];
            double R1 = (mid1 == N1 * 2) ? Integer.MAX_VALUE : nums1[(mid1)/2];
            double R2 = (mid2 == N2 * 2) ? Integer.MAX_VALUE : nums2[(mid2)/2];

            if (L1 > R2) lo = mid2 + 1;		// A1左半部分数字太大，需要将C1左移（C2同步右移）
            else if (L2 > R1) hi = mid2 - 1;	// A2左半部分数字太大，需要将C2左移（C1同步右移)
            else return (max(L1,L2) + min(R1, R2)) / 2;	// 如果满足条件L1 < R2 && L2 < R1，我们就找到了合适的切割点和最终的正确的中值
        }
        return -1;
    }
}
```

不知道你有没有被惊艳到哈哈，当我看懂了这个解决方案之后真的是叹为观止。哈哈，切割数组的方案在之后的问题中可能还会被用到，让我们拭目以待吧。