---
title: "Longest Valid Parentheses"
date: 2022-05-31T19:42:33+08:00
# post thumb
images:
- "images/leetcode/32-longest-valid-parentheses.png"
# author
author: "郁金香啊"
# description
description: "Longest Valid Parentheses"
# Taxonomies
categories: ["LeetCode","算法"]
tags: ["Java","LeetCode","算法","困难难度"]
type: "regular"
draft: false
---
给定一个由左括号和右括号组成的字符串，找到其中最长的括号正确组合的字串。

## 示例
**示例 1:**
```markdown
输入: s = "(()"
输出: 2
解释: 最长的有效字串是"()".
```

**示例 2:**
```markdown
输入: s = ")()())"
输出: 4
解释: 最长的有效的字串是 "()()".
```

**示例 3:**
```markdown
输入: s = ""
输出: 0
```

**限制条件:**
* `0 <= s.length <= 3 * 104`
* `s[i] is '(', or ')'.`

## 解决方案
### 解决方案 1 - 动态规划
让我们看下题目，求解最长字串，此处表明我们需要得到一个最优解。这个字串必须是有效的字串，左右括号的匹配必须要合理，此处则是我们的限制条件。好的，看上去已经比较像一个动态规划的问题了。

我们给定一个字串`()(())`，因为整个字符串比较短，大家肉眼直接可以看出最终的结果就是6了。现在让我们看下使用动态规划的话怎么一步步得到最终的结果。

此处我们先定义一下我们的状态，我们使用一个数组`dp`来存储每一个字符与其前面所有字符所能组成的最长的有效的字串长度。我们先将其值初始化为0。

```markdown
(  )  (  )  (  (  )  )  //str
0  1  2  3  4  5  6  7  //index
0  0  0  0  0  0  0  0  //dp
```

接下来，我们需要计算出所有字符可能组成的最长有效字串的长度。我们注意到如果一个字串是以左括号结尾的，那么这个字串不可能是一个有效的字串。所以实际上我们只需要找到所有右括号可能组成的最长字串就好了。

要计算一个右括号可能组成的最长有效字串，我们此处分几种情况来看。我们按照从左到右的顺序做一遍遍历来看下。

* 索引0 - 是左括号，可能与左边所有字符组成的有效字串长度为0。
* 索引1 - 是又括号，与索引0位置的左括号恰好组成一对有效的组合，由于索引0左边没有其他字符了，所以最长字串长度就是2。
* 索引2 - 是左括号，0。
* 索引3 - 是右括号，与索引2位置的左括号刚好组成一对，有效字串长度为2；此外，他们左边刚好也是一对匹配的括号，所以最长字串长度为4。
* 索引4 - 是左括号，0。
* 索引5 - 是左括号，0。
* 索引6 - 是右括号，与索引5位置的左括号刚好组成一对，有效字串长度为2；索引4位置最长字串长度是0，因为其是左括号，明显索引5，6的括号组合没法再和前面组成更长的字串了。
* 索引7 - 是右括号，此处需要注意，与7进行组合的括号应该是4，因为5，6两两组合，那么7应该是和4进行匹配。其实此处中间的空隙就是位置6最长字串的长度，相当于5，6相互抵消了。最终长度是`dp[i]=dp[i-1]+dp[i-dp[i-1]-2]+2`，其中`dp[i-1]`就是中间抵消的有效字符串的长度，`2`是索引`7`和`4`两个字符的长度，`dp[i-dp[i-1]-2]`则是索引`4`之前的字串，或者准确来说是索引`3`位置结尾的字串可能组成的最长有效字串长度。

让我们看下代码实现
```java
public class Solution {
    public int longestValidParenthes(String s) {
        int[] dp = new int[s.length()];
        int max = 0;
        for(int i = 1; i < s.length(); i++) {
            if(s.charAt(i) == ')') {
                if(s.charAt(i - 1) == '(') {
                    dp[i] = i > 1 ? 2 + dp[i - 2] : 2;
                } else if(i - dp[i - 1] > 0 && s.charAt(i - dp[i - 1] - 1) == '(') {
                    dp[i] = dp[i - 1] + 2 + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0);
                }
            }

            max = Math.max(max, dp[i]);
        }

        return max;
    }
}
```

### 解决方案 2 - 栈
注意到我们上一个解决方案中起到过一点，两个括号一旦完成匹配，就像是它们相互抵消了一样。

如果我们用栈来进行实现，每当我们遇到左括号我们就对其进行入栈，如果遇到右括号，我们就将栈顶的左括号出栈。一个出栈的操作其实就代表我们完成了一次匹配。

不过实际入栈出栈的并不是括号字符，而是我们的索引，因为我们需要使用索引信息来计算出字串长度，并得到最大字串长度。

```markdown
* ()()(()) / [-1] / 0
* )()(()) / [-1,0] / 0
* ()(()) / [] / 1 - (-1) = 2
* )(()) / [-1,2] / 2
* (()) / [] / 3 - (-1) = 4
* ()) / [-1,4] / 4
* )) / [-1,4,5,] / 4
* ) / [-1,4] / 4
*  / [] / 7 - (-1) = 8
```

代码实现

```java
public class Solution {
    public int longestValidParentheses__(String s) {
        int max = 0;

        Stack<Integer> stack = new Stack<>();

        stack.push(-1);
        for (int i = 0; i < s.length(); i++) {
            if(s.charAt(i) == '(') {
                stack.push(i);
            } else {
                stack.pop();
                if(stack.empty()) {
                    stack.push(i);
                } else {
                    max = Math.max(max, i - stack.peek());
                }
            }
        }

        return max;
    }
}
```

### 解决方案 3 
我们观察整个扫描的过程，如果我们将左括号和右括号的数量计数
* 如果左括号数量大于右括号数量，那么，接着向右边遍历的话，有可能找到足够多的右括号然后组成一个左右括号匹配的字符串。
* 如果左括号数量等于右括号的数量，那么此时就是匹配的，字串长度就是左右括号数量之和。
* 入股左括号数量少于右括号数量，那么此时无论如何都不可能组成一个左右括号匹配的字符串了，此时左右括号计数归零，相当于从当前位置重新开始寻找。

```markdown
* ()()(()) / 0 / 0 / 0 / ""    依次为左括号数量，右括号数量，最长字串长度，最长字串
* )()(()) / 1 / 0 / 0 / ""
* ()(()) / 1 / 1 / 2 / "()"
* )(()) / 2 / 1 / 2 / "()"
* (()) / 2 / 2 / 4 / "()()"
* ()) / 3 / 2 / 4 / "()()"
* )) / 4 / 2 / 4 / "()()"
* ) / 4 / 3 / 4 / "()()"
*  / 4 / 4 / 8 / "()()(())"
```

```java
public class Solution {
    public int longestValidParentheses(String s) {
        int left = 0, right = 0, max = 0;

        for(int i = 0; i < s.length();i++) {
            if(s.charAt(i) == '(') {
                left++;
            } else {
                right++;
            }

            if(left == right) {
                max = Math.max(max, right << 1);
            } else if(right > left) {
                left = right = 0;
            }
        }

        left = right = 0;

        for(int i = s.length() - 1; i >= 0; i--) {
            if(s.charAt(i) == '(') {
                left++;
            } else {
                right++;
            }

            if(left == right) {
                max = Math.max(max, left << 1);
            } else if(left > right) {
                left = right = 0;
            }
        }

        return max;
    }
}
```